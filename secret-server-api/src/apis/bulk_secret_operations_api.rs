/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bulk_secret_operations_service_activate_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceActivateSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_add_share_permissions_to_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceAddSharePermissionsToSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_assign_secrets_to_jumpbox_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceAssignSecretsToJumpboxRouteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_assign_secrets_to_secret_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceAssignSecretsToSecretPolicyError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_assign_secrets_to_site`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceAssignSecretsToSiteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_change_secrets_passwords_remotely`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceChangeSecretsPasswordsRemotelyError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_change_security_options_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceChangeSecurityOptionsSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_convert_secrets_to_secret_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceConvertSecretsToSecretTypeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_deactivate_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDeactivateSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_delete_dependencies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDeleteDependenciesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_auto_change_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableAutoChangeSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_checkout_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableCheckoutSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_dependencies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableDependenciesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_heartbeat_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableHeartbeatSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_hide_launcher_password_for_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableHideLauncherPasswordForSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_disable_require_view_comment_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceDisableRequireViewCommentSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_edit_share_permissions_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEditSharePermissionsSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_auto_change_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableAutoChangeSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_checkout_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableCheckoutSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_dependencies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableDependenciesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_heartbeat_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableHeartbeatSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_hide_launcher_password_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableHideLauncherPasswordSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_inherit_permissions_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableInheritPermissionsSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_enable_require_view_comment_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceEnableRequireViewCommentSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_move_secrets_to_folder`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceMoveSecretsToFolderError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_request_erase_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceRequestEraseSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_run_heartbeat_for_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceRunHeartbeatForSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_set_dependencies_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceSetDependenciesPasswordError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_set_privileged_account_for_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceSetPrivilegedAccountForSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_update_associated_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceUpdateAssociatedSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_secret_operations_service_update_password_requirement_for_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkSecretOperationsServiceUpdatePasswordRequirementForSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Activate each Secret.
pub async fn bulk_secret_operations_service_activate_secrets(configuration: &configuration::Configuration, args: Option<models::ActivateSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceActivateSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/activate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceActivateSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add share to each Secret with supplied Permissions.
pub async fn bulk_secret_operations_service_add_share_permissions_to_secrets(configuration: &configuration::Configuration, args: Option<models::AddSharePermissionArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceAddSharePermissionsToSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/add-share", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceAddSharePermissionsToSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign each Secret to the supplied Jumpbox route.
pub async fn bulk_secret_operations_service_assign_secrets_to_jumpbox_route(configuration: &configuration::Configuration, args: Option<models::AssignSecretsToJumpboxRouteArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceAssignSecretsToJumpboxRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/assign-jumpbox-route", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceAssignSecretsToJumpboxRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign each Secret to the supplied Secret Policy.
pub async fn bulk_secret_operations_service_assign_secrets_to_secret_policy(configuration: &configuration::Configuration, args: Option<models::AssignSecretsToSecretPolicyArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceAssignSecretsToSecretPolicyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/assign-secret-policy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceAssignSecretsToSecretPolicyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign each Secret to the supplied site.
pub async fn bulk_secret_operations_service_assign_secrets_to_site(configuration: &configuration::Configuration, args: Option<models::AssignSecretsToSiteArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceAssignSecretsToSiteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/assign-site", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceAssignSecretsToSiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the password remotely of each Secret.
pub async fn bulk_secret_operations_service_change_secrets_passwords_remotely(configuration: &configuration::Configuration, args: Option<models::ChangeSecretsPasswordsRemotelyArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceChangeSecretsPasswordsRemotelyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/change-password-remotely", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceChangeSecretsPasswordsRemotelyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change Security Options for each Secret.
pub async fn bulk_secret_operations_service_change_security_options_secrets(configuration: &configuration::Configuration, args: Option<models::ChangeSecurityOptionsSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceChangeSecurityOptionsSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/change-security-options", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceChangeSecurityOptionsSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Convert each Secret to the supplied type.
pub async fn bulk_secret_operations_service_convert_secrets_to_secret_type(configuration: &configuration::Configuration, args: Option<models::ConvertSecretsSecretTypeArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceConvertSecretsToSecretTypeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/convert-type", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceConvertSecretsToSecretTypeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deactivate each Secret.
pub async fn bulk_secret_operations_service_deactivate_secrets(configuration: &configuration::Configuration, args: Option<models::DeactivateSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDeactivateSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/deactivate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDeactivateSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete Dependencies for each Secret.
pub async fn bulk_secret_operations_service_delete_dependencies(configuration: &configuration::Configuration, args: Option<models::DeleteDependenciesArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDeleteDependenciesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/delete-dependencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDeleteDependenciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable AutoChange for each Secret.
pub async fn bulk_secret_operations_service_disable_auto_change_secrets(configuration: &configuration::Configuration, args: Option<models::DisableAutoChangeSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableAutoChangeSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-autochange", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableAutoChangeSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable Checkout for each Secret.
pub async fn bulk_secret_operations_service_disable_checkout_secrets(configuration: &configuration::Configuration, args: Option<models::DisableCheckoutSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableCheckoutSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-checkout", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableCheckoutSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable Dependencies for each Secret.
pub async fn bulk_secret_operations_service_disable_dependencies(configuration: &configuration::Configuration, args: Option<models::DisableDependenciesArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableDependenciesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-dependencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableDependenciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable Heartbeat for each Secret.
pub async fn bulk_secret_operations_service_disable_heartbeat_secrets(configuration: &configuration::Configuration, args: Option<models::DisableHeartbeatSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableHeartbeatSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-heartbeat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableHeartbeatSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable Hide Launcher Password for each Secret.
pub async fn bulk_secret_operations_service_disable_hide_launcher_password_for_secrets(configuration: &configuration::Configuration, args: Option<models::DisableHideLauncherPasswordForSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableHideLauncherPasswordForSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-hide-launcher-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableHideLauncherPasswordForSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable Require View Comment for each Secret.
pub async fn bulk_secret_operations_service_disable_require_view_comment_secrets(configuration: &configuration::Configuration, args: Option<models::DisableRequireViewCommentSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceDisableRequireViewCommentSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/disable-require-view-comment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceDisableRequireViewCommentSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edit each Secret and apply the supplied share Permissions.
pub async fn bulk_secret_operations_service_edit_share_permissions_secrets(configuration: &configuration::Configuration, args: Option<models::EditSharePermissionsSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEditSharePermissionsSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/edit-share", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEditSharePermissionsSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable AutoChange for each Secret.
pub async fn bulk_secret_operations_service_enable_auto_change_secrets(configuration: &configuration::Configuration, args: Option<models::EnableAutoChangeSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableAutoChangeSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-autochange", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableAutoChangeSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Checkout for each Secret.
pub async fn bulk_secret_operations_service_enable_checkout_secrets(configuration: &configuration::Configuration, args: Option<models::EnableCheckoutSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableCheckoutSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-checkout", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableCheckoutSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Dependencies for each Secret.
pub async fn bulk_secret_operations_service_enable_dependencies(configuration: &configuration::Configuration, args: Option<models::EnableDependenciesArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableDependenciesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-dependencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableDependenciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Heartbeat for each Secret.
pub async fn bulk_secret_operations_service_enable_heartbeat_secrets(configuration: &configuration::Configuration, args: Option<models::EnableHeartbeatSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableHeartbeatSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-heartbeat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableHeartbeatSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Hide Launcher Password for each Secret.
pub async fn bulk_secret_operations_service_enable_hide_launcher_password_secrets(configuration: &configuration::Configuration, args: Option<models::EnableHideLauncherPasswordSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableHideLauncherPasswordSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-hide-launcher-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableHideLauncherPasswordSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Inherit Permissions for each Secret.
pub async fn bulk_secret_operations_service_enable_inherit_permissions_secrets(configuration: &configuration::Configuration, args: Option<models::EnableInheritPermissionsSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableInheritPermissionsSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-inherit-permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableInheritPermissionsSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Require View Comment for each Secret.
pub async fn bulk_secret_operations_service_enable_require_view_comment_secrets(configuration: &configuration::Configuration, args: Option<models::EnableRequireViewCommentSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceEnableRequireViewCommentSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/enable-require-view-comment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceEnableRequireViewCommentSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Move selected Secrets to a specified Folder.
pub async fn bulk_secret_operations_service_move_secrets_to_folder(configuration: &configuration::Configuration, args: Option<models::MoveSecretsToFolderArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceMoveSecretsToFolderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/move-to-folder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceMoveSecretsToFolderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request Erase for each Secret.
pub async fn bulk_secret_operations_service_request_erase_secrets(configuration: &configuration::Configuration, args: Option<models::RequestEraseSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceRequestEraseSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/request-erase", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceRequestEraseSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Run Heartbeat for selected Secrets.
pub async fn bulk_secret_operations_service_run_heartbeat_for_secrets(configuration: &configuration::Configuration, args: Option<models::RunHeartbeatForSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceRunHeartbeatForSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/run-heartbeat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceRunHeartbeatForSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set Password dependencies for each Secret.
pub async fn bulk_secret_operations_service_set_dependencies_password(configuration: &configuration::Configuration, args: Option<models::SetDependencyPasswordArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceSetDependenciesPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/set-dependencies-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceSetDependenciesPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a Privileged Account for selected Secrets.
pub async fn bulk_secret_operations_service_set_privileged_account_for_secrets(configuration: &configuration::Configuration, args: Option<models::SetPrivilegedAccountForSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceSetPrivilegedAccountForSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/set-privileged-account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceSetPrivilegedAccountForSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Associate each Secret in a list with every Secret in a second list.
pub async fn bulk_secret_operations_service_update_associated_secrets(configuration: &configuration::Configuration, args: Option<models::UpdateAssociatedSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceUpdateAssociatedSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/update-associated-secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceUpdateAssociatedSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a Password Requirement for selected Secrets.
pub async fn bulk_secret_operations_service_update_password_requirement_for_secrets(configuration: &configuration::Configuration, args: Option<models::UpdatePasswordRequirementForSecretsArgs>) -> Result<models::BulkOperationResponseMessage, Error<BulkSecretOperationsServiceUpdatePasswordRequirementForSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/bulk-secret-operations/update-password-requirement", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkSecretOperationsServiceUpdatePasswordRequirementForSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

