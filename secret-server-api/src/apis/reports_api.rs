/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`reports_service_create_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceCreateReportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_create_report_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceCreateReportCategoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_create_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceCreateReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete_report_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteReportCategoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete_report_category_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteReportCategoryV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete_report_schedule_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteReportScheduleV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_delete_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDeleteV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_download_historical_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDownloadHistoricalReportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_download_report_csv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceDownloadReportCsvError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceEmailError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_execute`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceExecuteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceExportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_categories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetCategoriesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_chart_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetChartTypesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_default_parameters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetDefaultParametersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_audits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportAuditsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_audits_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportAuditsByIdError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportCategoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_category_permission_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportCategoryPermissionOptionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_category_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportCategoryPermissionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportDetailError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_permission_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportPermissionOptionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportPermissionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_permissions_from_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportPermissionsFromCategoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_get_report_schedule_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceGetReportScheduleHistoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_lookup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceLookupError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_search_report_schedule_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceSearchReportScheduleHistoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_search_report_schedules`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceSearchReportSchedulesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_search_report_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceSearchReportSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_stub_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceStubReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_undelete_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUndeleteReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_undelete_system_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUndeleteSystemReportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_update_report`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUpdateReportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_update_report_category`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUpdateReportCategoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_update_report_category_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUpdateReportCategoryPermissionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_update_report_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUpdateReportPermissionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reports_service_update_report_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReportsServiceUpdateReportScheduleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Creates a new Report and returns the report
pub async fn reports_service_create_report(configuration: &configuration::Configuration, args: Option<models::ReportCreateArgs>) -> Result<models::ReportModel, Error<ReportsServiceCreateReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceCreateReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create Report Category
pub async fn reports_service_create_report_category(configuration: &configuration::Configuration, args: Option<models::ReportCategoryCreateArgs>) -> Result<models::ReportCategoryDetailModel, Error<ReportsServiceCreateReportCategoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/categories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportCategoryDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportCategoryDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceCreateReportCategoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create Report Schedule
pub async fn reports_service_create_report_schedule(configuration: &configuration::Configuration, args: Option<models::ReportScheduleCreateArgs>) -> Result<models::ReportScheduleModel, Error<ReportsServiceCreateReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/schedules", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportScheduleModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportScheduleModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceCreateReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a report by ID
pub async fn reports_service_delete(configuration: &configuration::Configuration, id: i32) -> Result<bool, Error<ReportsServiceDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/reports/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This will delete the report category and all assigned reports will be set inactive
pub async fn reports_service_delete_report_category(configuration: &configuration::Configuration, report_category_id: i32) -> Result<bool, Error<ReportsServiceDeleteReportCategoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;

    let uri_str = format!("{}/v1/reports/categories/{reportCategoryId}", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteReportCategoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This will delete the report category and all assigned reports will be set inactive
pub async fn reports_service_delete_report_category_v2(configuration: &configuration::Configuration, report_category_id: i32) -> Result<models::DeletedModel, Error<ReportsServiceDeleteReportCategoryV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;

    let uri_str = format!("{}/v2/reports/categories/{reportCategoryId}", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteReportCategoryV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete Report Schedule
pub async fn reports_service_delete_report_schedule(configuration: &configuration::Configuration, report_schedule_id: i32) -> Result<bool, Error<ReportsServiceDeleteReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleId}", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete Report Schedule
pub async fn reports_service_delete_report_schedule_v2(configuration: &configuration::Configuration, report_schedule_id: i32) -> Result<models::DeletedModel, Error<ReportsServiceDeleteReportScheduleV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;

    let uri_str = format!("{}/v2/reports/schedules/{reportScheduleId}", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteReportScheduleV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a report by ID
pub async fn reports_service_delete_v2(configuration: &configuration::Configuration, id: i32) -> Result<models::DeletedModel, Error<ReportsServiceDeleteV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v2/reports/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDeleteV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download historical report from a schedule
pub async fn reports_service_download_historical_report(configuration: &configuration::Configuration, report_schedule_history_id: i32) -> Result<models::HttpResponseMessage, Error<ReportsServiceDownloadHistoricalReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_history_id = report_schedule_history_id;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleHistoryId}/history/download", configuration.base_path, reportScheduleHistoryId=p_path_report_schedule_history_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HttpResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HttpResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDownloadHistoricalReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Will stream the report as a csv file.  Only a few select reports are currently supported.
pub async fn reports_service_download_report_csv(configuration: &configuration::Configuration, parameters_left_square_bracket_0_right_square_bracket__name: Option<&str>, parameters_left_square_bracket_0_right_square_bracket__value: Option<&str>, report_id: Option<i32>) -> Result<String, Error<ReportsServiceDownloadReportCsvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_parameters_left_square_bracket_0_right_square_bracket__name = parameters_left_square_bracket_0_right_square_bracket__name;
    let p_query_parameters_left_square_bracket_0_right_square_bracket__value = parameters_left_square_bracket_0_right_square_bracket__value;
    let p_query_report_id = report_id;

    let uri_str = format!("{}/v1/reports/download-csv", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_parameters_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("parameters[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parameters_left_square_bracket_0_right_square_bracket__value {
        req_builder = req_builder.query(&[("parameters[0].value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_report_id {
        req_builder = req_builder.query(&[("reportId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceDownloadReportCsvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Email a report
pub async fn reports_service_email(configuration: &configuration::Configuration, id: i32, args: Option<models::ReportEmailArgs>) -> Result<models::ReportEmailResponse, Error<ReportsServiceEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/{id}/email", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportEmailResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportEmailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Executes a Report and returns the results
pub async fn reports_service_execute(configuration: &configuration::Configuration, args: Option<models::ReportExecuteArgs>) -> Result<models::ReportExecuteModel, Error<ReportsServiceExecuteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/execute", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportExecuteModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportExecuteModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceExecuteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exports a Report and returns the results
pub async fn reports_service_export(configuration: &configuration::Configuration, args: Option<models::ReportExportArgs>) -> Result<String, Error<ReportsServiceExportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/export", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceExportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the report categories
pub async fn reports_service_get_categories(configuration: &configuration::Configuration, ) -> Result<Vec<models::ReportCategory>, Error<ReportsServiceGetCategoriesError>> {

    let uri_str = format!("{}/v1/reports/categories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReportCategory&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReportCategory&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetCategoriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the report chart types
pub async fn reports_service_get_chart_types(configuration: &configuration::Configuration, ) -> Result<Vec<models::ReportChartType>, Error<ReportsServiceGetChartTypesError>> {

    let uri_str = format!("{}/v1/reports/charttypes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReportChartType&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReportChartType&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetChartTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the default parameters for the specified report
pub async fn reports_service_get_default_parameters(configuration: &configuration::Configuration, id: i32) -> Result<models::ReportDefaultParams, Error<ReportsServiceGetDefaultParametersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/reports/{id}/defaultparameters", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportDefaultParams`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportDefaultParams`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetDefaultParametersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all report audits
pub async fn reports_service_get_report_audits(configuration: &configuration::Configuration, is_exporting: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportAuditSummary, Error<ReportsServiceGetReportAuditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_is_exporting = is_exporting;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/audits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_exporting {
        req_builder = req_builder.query(&[("isExporting", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportAuditSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportAuditSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportAuditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get report audits by report Id
pub async fn reports_service_get_report_audits_by_id(configuration: &configuration::Configuration, id: i32, is_exporting: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportAuditSummary, Error<ReportsServiceGetReportAuditsByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_is_exporting = is_exporting;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/{id}/audits", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_exporting {
        req_builder = req_builder.query(&[("isExporting", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportAuditSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportAuditSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportAuditsByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Report Category
pub async fn reports_service_get_report_category(configuration: &configuration::Configuration, report_category_id: i32) -> Result<models::ReportCategoryDetailModel, Error<ReportsServiceGetReportCategoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;

    let uri_str = format!("{}/v1/reports/categories/{reportCategoryId}", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportCategoryDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportCategoryDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportCategoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Report Category Permission Options
pub async fn reports_service_get_report_category_permission_options(configuration: &configuration::Configuration, ) -> Result<Vec<models::ReportCategoryPermissionOptionModel>, Error<ReportsServiceGetReportCategoryPermissionOptionsError>> {

    let uri_str = format!("{}/v1/reports/categories/permissions/options", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReportCategoryPermissionOptionModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReportCategoryPermissionOptionModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportCategoryPermissionOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Report Category's Permissions
pub async fn reports_service_get_report_category_permissions(configuration: &configuration::Configuration, report_category_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportCategoryPermissionModel, Error<ReportsServiceGetReportCategoryPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/categories/{reportCategoryId}/permissions", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportCategoryPermissionModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportCategoryPermissionModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportCategoryPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a Report and returns the Report Model
pub async fn reports_service_get_report_detail(configuration: &configuration::Configuration, id: i32) -> Result<models::ReportModel, Error<ReportsServiceGetReportDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/reports/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Report Permission Options
pub async fn reports_service_get_report_permission_options(configuration: &configuration::Configuration, ) -> Result<Vec<models::ReportPermissionOptionModel>, Error<ReportsServiceGetReportPermissionOptionsError>> {

    let uri_str = format!("{}/v1/reports/permissions/options", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReportPermissionOptionModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReportPermissionOptionModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportPermissionOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Report's Permissions
pub async fn reports_service_get_report_permissions(configuration: &configuration::Configuration, report_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportPermissionModel, Error<ReportsServiceGetReportPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_id = report_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/{reportId}/permissions", configuration.base_path, reportId=p_path_report_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportPermissionModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportPermissionModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Report's Permissions from a Report Category
pub async fn reports_service_get_report_permissions_from_category(configuration: &configuration::Configuration, report_category_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportPermissionModel, Error<ReportsServiceGetReportPermissionsFromCategoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/{reportCategoryId}/permissions-from-category", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportPermissionModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportPermissionModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportPermissionsFromCategoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Report Schedule
pub async fn reports_service_get_report_schedule(configuration: &configuration::Configuration, report_schedule_id: i32) -> Result<models::ReportScheduleModel, Error<ReportsServiceGetReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleId}", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportScheduleModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportScheduleModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Report Schedule History
pub async fn reports_service_get_report_schedule_history(configuration: &configuration::Configuration, report_schedule_history_id: i32) -> Result<models::PagingOfReportScheduleHistorySummaryModel, Error<ReportsServiceGetReportScheduleHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_history_id = report_schedule_history_id;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleHistoryId}/history", configuration.base_path, reportScheduleHistoryId=p_path_report_schedule_history_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportScheduleHistorySummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportScheduleHistorySummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceGetReportScheduleHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page reports, returning only group ID and name
pub async fn reports_service_lookup(configuration: &configuration::Configuration, filter_category_id: Option<i32>, filter_include_inactive: Option<bool>, filter_report_ids: Option<&str>, filter_report_name: Option<&str>, filter_search_text: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportLookup, Error<ReportsServiceLookupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_category_id = filter_category_id;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_report_ids = filter_report_ids;
    let p_query_filter_report_name = filter_report_name;
    let p_query_filter_search_text = filter_search_text;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/lookup", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_category_id {
        req_builder = req_builder.query(&[("filter.categoryId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_report_ids {
        req_builder = req_builder.query(&[("filter.reportIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_report_name {
        req_builder = req_builder.query(&[("filter.reportName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportLookup`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportLookup`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceLookupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search Report Schedule History
pub async fn reports_service_search_report_schedule_history(configuration: &configuration::Configuration, report_schedule_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportScheduleHistorySummaryModel, Error<ReportsServiceSearchReportScheduleHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleId}/history/search", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportScheduleHistorySummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportScheduleHistorySummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceSearchReportScheduleHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search Report Schedules
pub async fn reports_service_search_report_schedules(configuration: &configuration::Configuration, filter_include_deleted: Option<bool>, filter_report_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportScheduleSummaryModel, Error<ReportsServiceSearchReportSchedulesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_include_deleted = filter_include_deleted;
    let p_query_filter_report_id = filter_report_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports/schedules", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_include_deleted {
        req_builder = req_builder.query(&[("filter.includeDeleted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_report_id {
        req_builder = req_builder.query(&[("filter.reportId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportScheduleSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportScheduleSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceSearchReportSchedulesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page reports
pub async fn reports_service_search_report_summary(configuration: &configuration::Configuration, filter_category_id: Option<i32>, filter_include_inactive: Option<bool>, filter_report_ids: Option<&str>, filter_report_name: Option<&str>, filter_search_text: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfReportSummary, Error<ReportsServiceSearchReportSummaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_category_id = filter_category_id;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_report_ids = filter_report_ids;
    let p_query_filter_report_name = filter_report_name;
    let p_query_filter_search_text = filter_search_text;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/reports", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_category_id {
        req_builder = req_builder.query(&[("filter.categoryId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_report_ids {
        req_builder = req_builder.query(&[("filter.reportIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_report_name {
        req_builder = req_builder.query(&[("filter.reportName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceSearchReportSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stub Report Schedule
pub async fn reports_service_stub_report_schedule(configuration: &configuration::Configuration, report_id: i32) -> Result<models::ReportScheduleModel, Error<ReportsServiceStubReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_id = report_id;

    let uri_str = format!("{}/v1/reports/schedules/stub/{reportId}", configuration.base_path, reportId=p_path_report_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportScheduleModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportScheduleModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceStubReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Undelete Report Schedule
pub async fn reports_service_undelete_report_schedule(configuration: &configuration::Configuration, report_schedule_id: i32) -> Result<bool, Error<ReportsServiceUndeleteReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleId}/undelete", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUndeleteReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows user to undelete system reports only.  Non-system reports are required to be edited in order for the SQL to be valdiated properly.
pub async fn reports_service_undelete_system_report(configuration: &configuration::Configuration, report_id: i32) -> Result<models::UndeleteReportResponse, Error<ReportsServiceUndeleteSystemReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_id = report_id;

    let uri_str = format!("{}/v1/reports/{reportId}/undelete", configuration.base_path, reportId=p_path_report_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UndeleteReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UndeleteReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUndeleteSystemReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a Report and returns the report
pub async fn reports_service_update_report(configuration: &configuration::Configuration, id: i32, args: Option<models::ReportUpdateArgs>) -> Result<models::ReportModel, Error<ReportsServiceUpdateReportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUpdateReportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Report Category
pub async fn reports_service_update_report_category(configuration: &configuration::Configuration, report_category_id: i32, args: Option<models::ReportCategoryUpdateArgs>) -> Result<models::ReportCategoryDetailModel, Error<ReportsServiceUpdateReportCategoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/categories/{reportCategoryId}", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportCategoryDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportCategoryDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUpdateReportCategoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Category Report Permissions
pub async fn reports_service_update_report_category_permissions(configuration: &configuration::Configuration, report_category_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>, args: Option<models::ReportCategoryPermissionsUpdateArgs>) -> Result<models::PagingOfReportCategoryPermissionModel, Error<ReportsServiceUpdateReportCategoryPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_category_id = report_category_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/categories/{reportCategoryId}/permissions", configuration.base_path, reportCategoryId=p_path_report_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportCategoryPermissionModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportCategoryPermissionModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUpdateReportCategoryPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Report Permissions
pub async fn reports_service_update_report_permissions(configuration: &configuration::Configuration, report_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>, args: Option<models::ReportPermissionsUpdateArgs>) -> Result<models::PagingOfReportPermissionModel, Error<ReportsServiceUpdateReportPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_id = report_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/{reportId}/permissions", configuration.base_path, reportId=p_path_report_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfReportPermissionModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfReportPermissionModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUpdateReportPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Report Schedule
pub async fn reports_service_update_report_schedule(configuration: &configuration::Configuration, report_schedule_id: i32, args: Option<models::ReportScheduleUpdateArgs>) -> Result<models::ReportScheduleModel, Error<ReportsServiceUpdateReportScheduleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_report_schedule_id = report_schedule_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/reports/schedules/{reportScheduleId}", configuration.base_path, reportScheduleId=p_path_report_schedule_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReportScheduleModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReportScheduleModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReportsServiceUpdateReportScheduleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

