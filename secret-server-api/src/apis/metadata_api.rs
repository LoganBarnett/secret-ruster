/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`metadata_service_create_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceCreateMetadataError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_delete_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceDeleteMetadataError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_get_field_sections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceGetFieldSectionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_get_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceGetFieldsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_search_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceSearchMetadataError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_search_metadata_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceSearchMetadataHistoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_update_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceUpdateMetadataError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_service_update_metadata_field_section`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataServiceUpdateMetadataFieldSectionError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Create or update a metadata field for an item
pub async fn metadata_service_create_metadata(configuration: &configuration::Configuration, item_id: i32, item_type: &str, args: Option<models::MetadataCreateArgs>) -> Result<models::MetadataModel, Error<MetadataServiceCreateMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_item_id = item_id;
    let p_path_item_type = item_type;
    let p_body_args = args;

    let uri_str = format!("{}/v1/metadata/{itemType}/{itemId}", configuration.base_path, itemId=p_path_item_id, itemType=crate::apis::urlencode(p_path_item_type));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceCreateMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the metadata value and all history for that item
pub async fn metadata_service_delete_metadata(configuration: &configuration::Configuration, item_id: i32, item_type: &str, metadata_item_data_id: i32) -> Result<models::MetadataDeleteResponse, Error<MetadataServiceDeleteMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_item_id = item_id;
    let p_path_item_type = item_type;
    let p_path_metadata_item_data_id = metadata_item_data_id;

    let uri_str = format!("{}/v1/metadata/{itemType}/{itemId}/{metadataItemDataId}", configuration.base_path, itemId=p_path_item_id, itemType=crate::apis::urlencode(p_path_item_type), metadataItemDataId=p_path_metadata_item_data_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceDeleteMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return all of the metadata sections that have metadata for a specific item.
pub async fn metadata_service_get_field_sections(configuration: &configuration::Configuration, filter_item_id: Option<i32>, filter_metadata_section_filter_id: Option<i32>, filter_metadata_type: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfMetadataFieldSectionSummaryModel, Error<MetadataServiceGetFieldSectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_item_id = filter_item_id;
    let p_query_filter_metadata_section_filter_id = filter_metadata_section_filter_id;
    let p_query_filter_metadata_type = filter_metadata_type;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/metadata/field-sections", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_item_id {
        req_builder = req_builder.query(&[("filter.itemId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_metadata_section_filter_id {
        req_builder = req_builder.query(&[("filter.metadataSectionFilterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_metadata_type {
        req_builder = req_builder.query(&[("filter.metadataType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfMetadataFieldSectionSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfMetadataFieldSectionSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceGetFieldSectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of all of the metadata sections and fields that exist
pub async fn metadata_service_get_fields(configuration: &configuration::Configuration, ) -> Result<models::PagingOfMetadataFieldSummaryModel, Error<MetadataServiceGetFieldsError>> {

    let uri_str = format!("{}/v1/metadata/fields", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfMetadataFieldSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfMetadataFieldSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceGetFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page metadata
pub async fn metadata_service_search_metadata(configuration: &configuration::Configuration, filter_item_id: Option<i32>, filter_meta_data_field_id: Option<i32>, filter_metadata_type: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfMetadataSummaryModel, Error<MetadataServiceSearchMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_item_id = filter_item_id;
    let p_query_filter_meta_data_field_id = filter_meta_data_field_id;
    let p_query_filter_metadata_type = filter_metadata_type;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/metadata", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_item_id {
        req_builder = req_builder.query(&[("filter.itemId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_meta_data_field_id {
        req_builder = req_builder.query(&[("filter.metaDataFieldId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_metadata_type {
        req_builder = req_builder.query(&[("filter.metadataType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfMetadataSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfMetadataSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceSearchMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page metadata history
pub async fn metadata_service_search_metadata_history(configuration: &configuration::Configuration, is_exporting: Option<bool>, filter_end_date: Option<String>, filter_item_id: Option<i32>, filter_meta_data_field_id: Option<i32>, filter_metadata_type: Option<&str>, filter_start_date: Option<String>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfMetadataHistorySummaryModel, Error<MetadataServiceSearchMetadataHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_is_exporting = is_exporting;
    let p_query_filter_end_date = filter_end_date;
    let p_query_filter_item_id = filter_item_id;
    let p_query_filter_meta_data_field_id = filter_meta_data_field_id;
    let p_query_filter_metadata_type = filter_metadata_type;
    let p_query_filter_start_date = filter_start_date;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/metadata/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_exporting {
        req_builder = req_builder.query(&[("isExporting", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_end_date {
        req_builder = req_builder.query(&[("filter.endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_item_id {
        req_builder = req_builder.query(&[("filter.itemId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_meta_data_field_id {
        req_builder = req_builder.query(&[("filter.metaDataFieldId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_metadata_type {
        req_builder = req_builder.query(&[("filter.metadataType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_start_date {
        req_builder = req_builder.query(&[("filter.startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfMetadataHistorySummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfMetadataHistorySummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceSearchMetadataHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update or create a metadata field for an item
pub async fn metadata_service_update_metadata(configuration: &configuration::Configuration, item_id: i32, item_type: &str, args: Option<models::MetadataUpdateArgs>) -> Result<models::MetadataModel, Error<MetadataServiceUpdateMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_item_id = item_id;
    let p_path_item_type = item_type;
    let p_body_args = args;

    let uri_str = format!("{}/v1/metadata/{itemType}/{itemId}", configuration.base_path, itemId=p_path_item_id, itemType=crate::apis::urlencode(p_path_item_type));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceUpdateMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a metadata field section
pub async fn metadata_service_update_metadata_field_section(configuration: &configuration::Configuration, field_section_id: i32, item_id: Option<i32>, item_type: Option<&str>, args: Option<models::MetadataFieldSectionUpdateArgs>) -> Result<models::MetadataFieldSectionSummaryModel, Error<MetadataServiceUpdateMetadataFieldSectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_section_id = field_section_id;
    let p_query_item_id = item_id;
    let p_query_item_type = item_type;
    let p_body_args = args;

    let uri_str = format!("{}/v1/metadata/field-sections/{fieldSectionId}", configuration.base_path, fieldSectionId=p_path_field_section_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_item_id {
        req_builder = req_builder.query(&[("itemId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_item_type {
        req_builder = req_builder.query(&[("itemType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataFieldSectionSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataFieldSectionSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataServiceUpdateMetadataFieldSectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

