/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`platform_migration_service_enable_unified_mode`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceEnableUnifiedModeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_data_pre_check_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetDataPreCheckSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_data_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetDataSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_domain_pre_check_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetDomainPreCheckSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_enable_unified_mode_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetEnableUnifiedModeProgressError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetGroupsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_migration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetMigrationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_migration_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetMigrationLogsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_migration_progress`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetMigrationProgressError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_migrations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetMigrationsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_oidc_pre_check_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetOidcPreCheckSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetRolesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_get_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceGetUsersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_migrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceMigrateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_set_groups_to_migrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceSetGroupsToMigrateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_set_users_to_migrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceSetUsersToMigrateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`platform_migration_service_update_unified_mode_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlatformMigrationServiceUpdateUnifiedModeStatusError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// WARNING. This will enable unified mode on your system which forces everything to be read from Platform which could cause unwanted results. This is designed for internal use only.
pub async fn platform_migration_service_enable_unified_mode(configuration: &configuration::Configuration, args: Option<models::PlatformEnableUnifiedModeArgs>) -> Result<models::PlatformEnableUnifiedModeResponse, Error<PlatformMigrationServiceEnableUnifiedModeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/platform-migration/enable-unified-mode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformEnableUnifiedModeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformEnableUnifiedModeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceEnableUnifiedModeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Data Pre-Check Summary
pub async fn platform_migration_service_get_data_pre_check_summary(configuration: &configuration::Configuration, ) -> Result<models::PlatformDataMigrationDataPreCheckSummary, Error<PlatformMigrationServiceGetDataPreCheckSummaryError>> {

    let uri_str = format!("{}/v1/platform-migration/pre-check-data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationDataPreCheckSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationDataPreCheckSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetDataPreCheckSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Data Totals
pub async fn platform_migration_service_get_data_summary(configuration: &configuration::Configuration, ) -> Result<models::PlatformDataMigrationDataSummary, Error<PlatformMigrationServiceGetDataSummaryError>> {

    let uri_str = format!("{}/v1/platform-migration/data-summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationDataSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationDataSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetDataSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Domain Pre-Check Summary
pub async fn platform_migration_service_get_domain_pre_check_summary(configuration: &configuration::Configuration, ) -> Result<models::PlatformDataMigrationDomainPreCheckSummary, Error<PlatformMigrationServiceGetDomainPreCheckSummaryError>> {

    let uri_str = format!("{}/v1/platform-migration/pre-check-domains", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationDomainPreCheckSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationDomainPreCheckSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetDomainPreCheckSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Progress of enabling Unified Mode
pub async fn platform_migration_service_get_enable_unified_mode_progress(configuration: &configuration::Configuration, ) -> Result<models::PlatformEnableUnifiedModeProgressResponse, Error<PlatformMigrationServiceGetEnableUnifiedModeProgressError>> {

    let uri_str = format!("{}/v1/platform-migration/enable-unified-mode/progress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformEnableUnifiedModeProgressResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformEnableUnifiedModeProgressResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetEnableUnifiedModeProgressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Groups to Migrate
pub async fn platform_migration_service_get_groups(configuration: &configuration::Configuration, paging: Option<models::PagingOfPlatformDataMigrationGroupSummaryAndPlatformDataMigrationGroupFilter>) -> Result<models::PagingOfPlatformDataMigrationGroupSummary, Error<PlatformMigrationServiceGetGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_paging = paging;

    let uri_str = format!("{}/v1/platform-migration/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_paging);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationGroupSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationGroupSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Migration
pub async fn platform_migration_service_get_migration(configuration: &configuration::Configuration, migration_id: i32) -> Result<models::PlatformDataMigrationDetail, Error<PlatformMigrationServiceGetMigrationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_migration_id = migration_id;

    let uri_str = format!("{}/v1/platform-migration/migrations/{migrationId}", configuration.base_path, migrationId=p_path_migration_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetMigrationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Logs of Migrations
pub async fn platform_migration_service_get_migration_logs(configuration: &configuration::Configuration, filter_end_date: Option<String>, filter_log_level: Option<&str>, filter_object_type: Option<&str>, filter_search_term: Option<&str>, filter_start_date: Option<String>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfPlatformDataMigrationLogSummaryAndPlatformDataMigrationLogSearchFilter, Error<PlatformMigrationServiceGetMigrationLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_end_date = filter_end_date;
    let p_query_filter_log_level = filter_log_level;
    let p_query_filter_object_type = filter_object_type;
    let p_query_filter_search_term = filter_search_term;
    let p_query_filter_start_date = filter_start_date;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/platform-migration/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_end_date {
        req_builder = req_builder.query(&[("filter.endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_log_level {
        req_builder = req_builder.query(&[("filter.logLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_object_type {
        req_builder = req_builder.query(&[("filter.objectType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_term {
        req_builder = req_builder.query(&[("filter.searchTerm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_start_date {
        req_builder = req_builder.query(&[("filter.startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationLogSummaryAndPlatformDataMigrationLogSearchFilter`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationLogSummaryAndPlatformDataMigrationLogSearchFilter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetMigrationLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Progress of a Migration
pub async fn platform_migration_service_get_migration_progress(configuration: &configuration::Configuration, migration_id: Option<i32>) -> Result<models::PlatformDataMigrationProgressSummary, Error<PlatformMigrationServiceGetMigrationProgressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_migration_id = migration_id;

    let uri_str = format!("{}/v1/platform-migration/progress", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_migration_id {
        req_builder = req_builder.query(&[("migrationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationProgressSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationProgressSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetMigrationProgressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Migrations
pub async fn platform_migration_service_get_migrations(configuration: &configuration::Configuration, filter_end_date: Option<String>, filter_start_date: Option<String>, filter_username: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfPlatformDataMigrationSummary, Error<PlatformMigrationServiceGetMigrationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_end_date = filter_end_date;
    let p_query_filter_start_date = filter_start_date;
    let p_query_filter_username = filter_username;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/platform-migration/migrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_end_date {
        req_builder = req_builder.query(&[("filter.endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_start_date {
        req_builder = req_builder.query(&[("filter.startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_username {
        req_builder = req_builder.query(&[("filter.username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetMigrationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Federated User Sources Pre-Check Summary
pub async fn platform_migration_service_get_oidc_pre_check_summary(configuration: &configuration::Configuration, ) -> Result<models::PlatformDataMigrationFederatedUserSourcesPreCheckSummary, Error<PlatformMigrationServiceGetOidcPreCheckSummaryError>> {

    let uri_str = format!("{}/v1/platform-migration/federated-user-sources", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationFederatedUserSourcesPreCheckSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationFederatedUserSourcesPreCheckSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetOidcPreCheckSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Roles to Migrate
pub async fn platform_migration_service_get_roles(configuration: &configuration::Configuration, paging: Option<models::PagingOfPlatformDataMigrationRoleSummaryAndPlatformDataMigrationRoleFilter>) -> Result<models::PagingOfPlatformDataMigrationRoleSummaryAndPlatformDataMigrationRoleFilter, Error<PlatformMigrationServiceGetRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_paging = paging;

    let uri_str = format!("{}/v1/platform-migration/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_paging);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationRoleSummaryAndPlatformDataMigrationRoleFilter`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationRoleSummaryAndPlatformDataMigrationRoleFilter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Users to Migrate
pub async fn platform_migration_service_get_users(configuration: &configuration::Configuration, paging: Option<models::PagingOfPlatformDataMigrationUserSummaryAndPlatformDataMigrationUserFilter>) -> Result<models::PagingOfPlatformDataMigrationUserSummaryAndPlatformDataMigrationUserFilter, Error<PlatformMigrationServiceGetUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_paging = paging;

    let uri_str = format!("{}/v1/platform-migration/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_paging);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationUserSummaryAndPlatformDataMigrationUserFilter`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfPlatformDataMigrationUserSummaryAndPlatformDataMigrationUserFilter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceGetUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Migrate to Platform
pub async fn platform_migration_service_migrate(configuration: &configuration::Configuration, args: Option<models::PlatformDataMigrationArgs>) -> Result<models::PlatformDataMigrationResponse, Error<PlatformMigrationServiceMigrateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/platform-migration/migrate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformDataMigrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformDataMigrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceMigrateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set selected Groups whether or not to migrate.
pub async fn platform_migration_service_set_groups_to_migrate(configuration: &configuration::Configuration, args: Option<models::SetGroupsMigrationArgs>) -> Result<models::SetGroupsMigrationResponse, Error<PlatformMigrationServiceSetGroupsToMigrateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/platform-migration/set-groups-to-migrate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetGroupsMigrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetGroupsMigrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceSetGroupsToMigrateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set selected Users whether or not to migrate.
pub async fn platform_migration_service_set_users_to_migrate(configuration: &configuration::Configuration, args: Option<models::SetUsersMigrationArgs>) -> Result<models::SetUsersMigrationResponse, Error<PlatformMigrationServiceSetUsersToMigrateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/platform-migration/set-users-to-migrate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetUsersMigrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetUsersMigrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceSetUsersToMigrateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Unified Mode Status
pub async fn platform_migration_service_update_unified_mode_status(configuration: &configuration::Configuration, args: Option<models::PlatformUpdateUnifiedModeStatusArgs>) -> Result<models::PlatformUpdateUnifiedModeStatusResponse, Error<PlatformMigrationServiceUpdateUnifiedModeStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/platform-migration/update-unified-mode-status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlatformUpdateUnifiedModeStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlatformUpdateUnifiedModeStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlatformMigrationServiceUpdateUnifiedModeStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

