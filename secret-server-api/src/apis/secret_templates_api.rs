/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`secret_templates_service_add_password_dictionary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceAddPasswordDictionaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCopyError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_create_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCreateFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_create_secret_template_extended_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCreateSecretTemplateExtendedMappingError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_create_secret_template_launcher`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCreateSecretTemplateLauncherError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_create_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCreateTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_create_template_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceCreateTemplateFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_delete_extended_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceDeleteExtendedMappingError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_delete_password_dictionary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceDeletePasswordDictionaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_delete_secret_template_launcher`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceDeleteSecretTemplateLauncherError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_disable_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceDisableFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceExportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_generate_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGeneratePasswordError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_password_dictionaries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetPasswordDictionariesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_password_dictionary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetPasswordDictionaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_secret_template_extended_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetSecretTemplateExtendedMappingError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_secret_template_fields_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetSecretTemplateFieldsByIdError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_secret_template_launcher`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetSecretTemplateLauncherError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_secret_template_password_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetSecretTemplatePasswordTypeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_secret_templates_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetSecretTemplatesListError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_template_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetTemplateFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_get_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceGetV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_import_secret_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceImportSecretTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_patch_secret_template_password_changer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServicePatchSecretTemplatePasswordChangerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_patch_template_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServicePatchTemplateFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_patch_template_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServicePatchTemplateV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServicePutError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search_launcher_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchLauncherTypesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search_secret_template_extended_mappings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchSecretTemplateExtendedMappingsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search_secret_template_extended_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchSecretTemplateExtendedTypesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search_secret_template_launchers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchSecretTemplateLaunchersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_search_template_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSearchTemplateFieldsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_sort_template_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceSortTemplateFieldsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_stub_secret_template_extended_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceStubSecretTemplateExtendedMappingError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_stub_secret_template_launcher`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceStubSecretTemplateLauncherError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_stub_template_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceStubTemplateFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_update_password_dictionary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceUpdatePasswordDictionaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_update_secret_template_extended_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceUpdateSecretTemplateExtendedMappingError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_update_secret_template_launcher`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceUpdateSecretTemplateLauncherError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secret_templates_service_update_secret_template_password_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretTemplatesServiceUpdateSecretTemplatePasswordTypeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Add new password dictionary
pub async fn secret_templates_service_add_password_dictionary(configuration: &configuration::Configuration, dictionary_name: Option<&str>, file: Option<std::path::PathBuf>) -> Result<bool, Error<SecretTemplatesServiceAddPasswordDictionaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_dictionary_name = dictionary_name;
    let p_form_file = file;

    let uri_str = format!("{}/v1/secret-templates/password-requirements/password-dictionaries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_form_dictionary_name {
        multipart_form = multipart_form.text("dictionaryName", param_value.to_string());
    }
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceAddPasswordDictionaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Copy a single secret template by ID
pub async fn secret_templates_service_copy(configuration: &configuration::Configuration, id: i32, args: Option<models::SecretTemplateCopyArgs>) -> Result<models::SecretTemplateDetailModel, Error<SecretTemplatesServiceCopyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{id}/copy", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCopyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new Secret Template Field For Template
pub async fn secret_templates_service_create_field(configuration: &configuration::Configuration, template_id: i32, secret_template_field_create_args: Option<models::SecretTemplateFieldCreateArgs>) -> Result<models::SecretTemplateField, Error<SecretTemplatesServiceCreateFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_template_id = template_id;
    let p_body_secret_template_field_create_args = secret_template_field_create_args;

    let uri_str = format!("{}/v1/secret-templates/{templateId}", configuration.base_path, templateId=p_path_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_secret_template_field_create_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateField`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateField`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCreateFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create an extended mappings for a Secret Template
pub async fn secret_templates_service_create_secret_template_extended_mapping(configuration: &configuration::Configuration, extended_type_id: i32, secret_template_id: i32, args: Option<models::SecretTemplateExtendedMappingCreateArgs>) -> Result<models::SecretTemplateExtendedMappingModel, Error<SecretTemplatesServiceCreateSecretTemplateExtendedMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_extended_type_id = extended_type_id;
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/extended-mappings/{extendedTypeId}", configuration.base_path, extendedTypeId=p_path_extended_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCreateSecretTemplateExtendedMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a Launcher for a Secret Template
pub async fn secret_templates_service_create_secret_template_launcher(configuration: &configuration::Configuration, launcher_type_id: i32, secret_template_id: i32, args: Option<models::SecretTemplateLauncherCreateArgs>) -> Result<models::SecretTemplateLauncherModel, Error<SecretTemplatesServiceCreateSecretTemplateLauncherError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_launcher_type_id = launcher_type_id;
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/launchers/{launcherTypeId}", configuration.base_path, launcherTypeId=p_path_launcher_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateLauncherModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateLauncherModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCreateSecretTemplateLauncherError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new Secret Template
pub async fn secret_templates_service_create_template(configuration: &configuration::Configuration, secret_template_create_args: Option<models::SecretTemplateCreateArgs>) -> Result<models::SecretTemplateModel, Error<SecretTemplatesServiceCreateTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_secret_template_create_args = secret_template_create_args;

    let uri_str = format!("{}/v1/secret-templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_secret_template_create_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCreateTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a secret template field
pub async fn secret_templates_service_create_template_field(configuration: &configuration::Configuration, secret_template_id: i32, args: Option<models::SecretFieldCreateArgs>) -> Result<models::SecretTemplateFieldModel, Error<SecretTemplatesServiceCreateTemplateFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/fields", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceCreateTemplateFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an extended mapping
pub async fn secret_templates_service_delete_extended_mapping(configuration: &configuration::Configuration, extended_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateExtendedMappingDeleteResponseModel, Error<SecretTemplatesServiceDeleteExtendedMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_extended_type_id = extended_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/extended-mappings/{extendedTypeId}", configuration.base_path, extendedTypeId=p_path_extended_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExtendedMappingDeleteResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExtendedMappingDeleteResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceDeleteExtendedMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a specific custom password dictionary with the contents.
pub async fn secret_templates_service_delete_password_dictionary(configuration: &configuration::Configuration, id: i32) -> Result<bool, Error<SecretTemplatesServiceDeletePasswordDictionaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/secret-templates/password-requirements/password-dictionaries/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceDeletePasswordDictionaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete or remove the mapping of a specific launcher type from a specific Secret template
pub async fn secret_templates_service_delete_secret_template_launcher(configuration: &configuration::Configuration, launcher_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateLauncherDeleteResultModel, Error<SecretTemplatesServiceDeleteSecretTemplateLauncherError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_launcher_type_id = launcher_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/launchers/{launcherTypeId}", configuration.base_path, launcherTypeId=p_path_launcher_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateLauncherDeleteResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateLauncherDeleteResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceDeleteSecretTemplateLauncherError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable a Secret Template Field For Template
pub async fn secret_templates_service_disable_field(configuration: &configuration::Configuration, template_field_id: i32) -> Result<models::SecretTemplateField, Error<SecretTemplatesServiceDisableFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_template_field_id = template_field_id;

    let uri_str = format!("{}/v1/secret-templates/fields/{templateFieldId}", configuration.base_path, templateFieldId=p_path_template_field_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateField`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateField`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceDisableFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Export a single secret template by ID
pub async fn secret_templates_service_export(configuration: &configuration::Configuration, id: i32) -> Result<models::SecretTemplateExportModel, Error<SecretTemplatesServiceExportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/secret-templates/{id}/export", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExportModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExportModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceExportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a new password matching the Secret Field requirements
pub async fn secret_templates_service_generate_password(configuration: &configuration::Configuration, secretfield_id: i32) -> Result<String, Error<SecretTemplatesServiceGeneratePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secretfield_id = secretfield_id;

    let uri_str = format!("{}/v1/secret-templates/generate-password/{secretfieldId}", configuration.base_path, secretfieldId=p_path_secretfield_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGeneratePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the list of custom password dictionaries.
pub async fn secret_templates_service_get_password_dictionaries(configuration: &configuration::Configuration, ) -> Result<Vec<models::PasswordDictionaryModel>, Error<SecretTemplatesServiceGetPasswordDictionariesError>> {

    let uri_str = format!("{}/v1/secret-templates/password-requirements/password-dictionaries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PasswordDictionaryModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PasswordDictionaryModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetPasswordDictionariesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a file containing the items of a specific custom password dictionary.
pub async fn secret_templates_service_get_password_dictionary(configuration: &configuration::Configuration, id: i32) -> Result<(), Error<SecretTemplatesServiceGetPasswordDictionaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/secret-templates/password-requirements/password-dictionaries/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetPasswordDictionaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an extended mapping for a Secret Template
pub async fn secret_templates_service_get_secret_template_extended_mapping(configuration: &configuration::Configuration, extended_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateExtendedMappingModel, Error<SecretTemplatesServiceGetSecretTemplateExtendedMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_extended_type_id = extended_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/extended-mappings/{extendedTypeId}", configuration.base_path, extendedTypeId=p_path_extended_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetSecretTemplateExtendedMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of Secret Template fields by ID. Basic users are able to query and get this list.
pub async fn secret_templates_service_get_secret_template_fields_by_id(configuration: &configuration::Configuration, template_id: i32) -> Result<models::SecretTemplateFieldsModel, Error<SecretTemplatesServiceGetSecretTemplateFieldsByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_template_id = template_id;

    let uri_str = format!("{}/v1/secret-templates/fields/basic/{templateId}", configuration.base_path, templateId=p_path_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetSecretTemplateFieldsByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get launcher detail for a Secret Template
pub async fn secret_templates_service_get_secret_template_launcher(configuration: &configuration::Configuration, launcher_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateLauncherModel, Error<SecretTemplatesServiceGetSecretTemplateLauncherError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_launcher_type_id = launcher_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/launchers/{launcherTypeId}", configuration.base_path, launcherTypeId=p_path_launcher_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateLauncherModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateLauncherModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetSecretTemplateLauncherError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the password changer for a secret template if defined
pub async fn secret_templates_service_get_secret_template_password_type(configuration: &configuration::Configuration, secret_template_id: i32) -> Result<models::SecretTemplatePasswordTypeModel, Error<SecretTemplatesServiceGetSecretTemplatePasswordTypeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/password-type", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplatePasswordTypeModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplatePasswordTypeModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetSecretTemplatePasswordTypeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all Secret Templates.  Basic users are able to query and get this list.  Only returns active templates.
pub async fn secret_templates_service_get_secret_templates_list(configuration: &configuration::Configuration, filter_folder_id: Option<i32>, filter_only_include_creatable: Option<bool>, filter_only_include_templates_with_url: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateListModel, Error<SecretTemplatesServiceGetSecretTemplatesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_folder_id = filter_folder_id;
    let p_query_filter_only_include_creatable = filter_only_include_creatable;
    let p_query_filter_only_include_templates_with_url = filter_only_include_templates_with_url;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_folder_id {
        req_builder = req_builder.query(&[("filter.folderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_include_creatable {
        req_builder = req_builder.query(&[("filter.onlyIncludeCreatable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_include_templates_with_url {
        req_builder = req_builder.query(&[("filter.onlyIncludeTemplatesWithUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateListModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateListModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetSecretTemplatesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a secret template field
pub async fn secret_templates_service_get_template_field(configuration: &configuration::Configuration, secret_field_id: i32) -> Result<models::SecretTemplateFieldModel, Error<SecretTemplatesServiceGetTemplateFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_field_id = secret_field_id;

    let uri_str = format!("{}/v1/secret-templates/fields/{secretFieldId}", configuration.base_path, secretFieldId=p_path_secret_field_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetTemplateFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a single secret template details by Id
pub async fn secret_templates_service_get_v2(configuration: &configuration::Configuration, secret_template_id: i32) -> Result<models::SecretTemplateDetailModel, Error<SecretTemplatesServiceGetV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v2/secret-templates/{secretTemplateId}", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceGetV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Imports a secret template from xml
pub async fn secret_templates_service_import_secret_template(configuration: &configuration::Configuration, args: Option<models::SecretTemplateImportArgs>) -> Result<models::SecretTemplateModel, Error<SecretTemplatesServiceImportSecretTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceImportSecretTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create or assign password type settings on a secret template
pub async fn secret_templates_service_patch_secret_template_password_changer(configuration: &configuration::Configuration, secret_template_id: i32, args: Option<models::SecretTemplatePasswordTypePatchArgs>) -> Result<models::SecretTemplatePasswordTypeModel, Error<SecretTemplatesServicePatchSecretTemplatePasswordChangerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/password-type", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplatePasswordTypeModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplatePasswordTypeModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServicePatchSecretTemplatePasswordChangerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patch a secret template field
pub async fn secret_templates_service_patch_template_field(configuration: &configuration::Configuration, secret_template_field_id: i32, args: Option<models::SecretFieldPatchArgs>) -> Result<models::SecretTemplateFieldModel, Error<SecretTemplatesServicePatchTemplateFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_field_id = secret_template_field_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/fields/{secretTemplateFieldId}", configuration.base_path, secretTemplateFieldId=p_path_secret_template_field_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServicePatchTemplateFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patch secret template details
pub async fn secret_templates_service_patch_template_v2(configuration: &configuration::Configuration, secret_template_id: i32, args: Option<models::SecretTemplateDetailPatchArgs>) -> Result<models::SecretTemplateDetailModel, Error<SecretTemplatesServicePatchTemplateV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v2/secret-templates/{secretTemplateId}", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServicePatchTemplateV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Secret Template Field
pub async fn secret_templates_service_put(configuration: &configuration::Configuration, template_id: i32, args: Option<models::SecretTemplateFieldUpdateArgs>) -> Result<models::SecretTemplateField, Error<SecretTemplatesServicePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_template_id = template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{templateId}", configuration.base_path, templateId=p_path_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateField`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateField`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServicePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page secret templates
pub async fn secret_templates_service_search(configuration: &configuration::Configuration, filter_heartbeat_enabled: Option<&str>, filter_include_inactive: Option<bool>, filter_include_secret_count: Option<bool>, filter_password_type_ids: Option<Vec<i32>>, filter_password_type_ready: Option<&str>, filter_scan_item_template_id: Option<i32>, filter_search_text: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateSummary, Error<SecretTemplatesServiceSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_heartbeat_enabled = filter_heartbeat_enabled;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_secret_count = filter_include_secret_count;
    let p_query_filter_password_type_ids = filter_password_type_ids;
    let p_query_filter_password_type_ready = filter_password_type_ready;
    let p_query_filter_scan_item_template_id = filter_scan_item_template_id;
    let p_query_filter_search_text = filter_search_text;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_heartbeat_enabled {
        req_builder = req_builder.query(&[("filter.heartbeatEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_secret_count {
        req_builder = req_builder.query(&[("filter.includeSecretCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_password_type_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.passwordTypeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.passwordTypeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_password_type_ready {
        req_builder = req_builder.query(&[("filter.passwordTypeReady", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_item_template_id {
        req_builder = req_builder.query(&[("filter.scanItemTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a paged list of all of the Launcher Types that exist
pub async fn secret_templates_service_search_launcher_types(configuration: &configuration::Configuration, filter_application_name: Option<&str>, filter_include_inactive: Option<bool>, filter_include_system_launchers: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfLauncherTypeSummary, Error<SecretTemplatesServiceSearchLauncherTypesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_application_name = filter_application_name;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_system_launchers = filter_include_system_launchers;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates/launcher-types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_application_name {
        req_builder = req_builder.query(&[("filter.applicationName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_system_launchers {
        req_builder = req_builder.query(&[("filter.includeSystemLaunchers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfLauncherTypeSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfLauncherTypeSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchLauncherTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the extended mappings for a Secret Template
pub async fn secret_templates_service_search_secret_template_extended_mappings(configuration: &configuration::Configuration, filter_secret_template_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateExtendedMappingSummary, Error<SecretTemplatesServiceSearchSecretTemplateExtendedMappingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_secret_template_id = filter_secret_template_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates/extended-mappings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_secret_template_id {
        req_builder = req_builder.query(&[("filter.secretTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateExtendedMappingSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateExtendedMappingSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchSecretTemplateExtendedMappingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the extended types
pub async fn secret_templates_service_search_secret_template_extended_types(configuration: &configuration::Configuration, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateExtendedTypeSummary, Error<SecretTemplatesServiceSearchSecretTemplateExtendedTypesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates/extended-types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateExtendedTypeSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateExtendedTypeSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchSecretTemplateExtendedTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the Launchers for a Secret Template
pub async fn secret_templates_service_search_secret_template_launchers(configuration: &configuration::Configuration, filter_secret_template_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateLauncherSummary, Error<SecretTemplatesServiceSearchSecretTemplateLaunchersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_secret_template_id = filter_secret_template_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates/launchers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_secret_template_id {
        req_builder = req_builder.query(&[("filter.secretTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateLauncherSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateLauncherSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchSecretTemplateLaunchersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page secret template fields
pub async fn secret_templates_service_search_template_fields(configuration: &configuration::Configuration, filter_include_inactive: Option<bool>, filter_secret_template_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTemplateFieldSummaryModel, Error<SecretTemplatesServiceSearchTemplateFieldsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_secret_template_id = filter_secret_template_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secret-templates/fields/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_secret_template_id {
        req_builder = req_builder.query(&[("filter.secretTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTemplateFieldSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTemplateFieldSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSearchTemplateFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sort secret template fields for a secret template
pub async fn secret_templates_service_sort_template_fields(configuration: &configuration::Configuration, secret_template_id: i32, args: Option<models::SecretTemplateFieldSortArgs>) -> Result<models::SecretTemplateFieldSortResultModel, Error<SecretTemplatesServiceSortTemplateFieldsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/fields/sort", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldSortResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldSortResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceSortTemplateFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a stub that can be used to create an extended mapping
pub async fn secret_templates_service_stub_secret_template_extended_mapping(configuration: &configuration::Configuration, extended_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateExtendedMappingModel, Error<SecretTemplatesServiceStubSecretTemplateExtendedMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_extended_type_id = extended_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/extended-mappings/{extendedTypeId}/stub", configuration.base_path, extendedTypeId=p_path_extended_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceStubSecretTemplateExtendedMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a stub that can be used to create an launcher
pub async fn secret_templates_service_stub_secret_template_launcher(configuration: &configuration::Configuration, launcher_type_id: i32, secret_template_id: i32) -> Result<models::SecretTemplateLauncherModel, Error<SecretTemplatesServiceStubSecretTemplateLauncherError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_launcher_type_id = launcher_type_id;
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/launchers/{launcherTypeId}/stub", configuration.base_path, launcherTypeId=p_path_launcher_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateLauncherModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateLauncherModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceStubSecretTemplateLauncherError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve an empty secret template field
pub async fn secret_templates_service_stub_template_field(configuration: &configuration::Configuration, ) -> Result<models::SecretTemplateFieldModel, Error<SecretTemplatesServiceStubTemplateFieldError>> {

    let uri_str = format!("{}/v1/secret-templates/fields/stub", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateFieldModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateFieldModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceStubTemplateFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates password dictionary
pub async fn secret_templates_service_update_password_dictionary(configuration: &configuration::Configuration, dictionary_id: Option<i32>, dictionary_name: Option<&str>, file: Option<std::path::PathBuf>) -> Result<bool, Error<SecretTemplatesServiceUpdatePasswordDictionaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_dictionary_id = dictionary_id;
    let p_form_dictionary_name = dictionary_name;
    let p_form_file = file;

    let uri_str = format!("{}/v1/secret-templates/password-requirements/password-dictionaries", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_form_dictionary_id {
        multipart_form = multipart_form.text("dictionaryId", param_value.to_string());
    }
    if let Some(param_value) = p_form_dictionary_name {
        multipart_form = multipart_form.text("dictionaryName", param_value.to_string());
    }
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceUpdatePasswordDictionaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update extended mappings for a Secret Template
pub async fn secret_templates_service_update_secret_template_extended_mapping(configuration: &configuration::Configuration, extended_type_id: i32, secret_template_id: i32, args: Option<models::SecretTemplateExtendedMappingUpdateArgs>) -> Result<models::SecretTemplateExtendedMappingModel, Error<SecretTemplatesServiceUpdateSecretTemplateExtendedMappingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_extended_type_id = extended_type_id;
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/extended-mappings/{extendedTypeId}", configuration.base_path, extendedTypeId=p_path_extended_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateExtendedMappingModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceUpdateSecretTemplateExtendedMappingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Launchers for a Secret Template
pub async fn secret_templates_service_update_secret_template_launcher(configuration: &configuration::Configuration, launcher_type_id: i32, secret_template_id: i32, args: Option<models::SecretTemplateLauncherUpdateArgs>) -> Result<models::SecretTemplateLauncherModel, Error<SecretTemplatesServiceUpdateSecretTemplateLauncherError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_launcher_type_id = launcher_type_id;
    let p_path_secret_template_id = secret_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/{secretTemplateId}/launchers/{launcherTypeId}", configuration.base_path, launcherTypeId=p_path_launcher_type_id, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateLauncherModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateLauncherModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceUpdateSecretTemplateLauncherError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update A Secret template Password Type Options and Fields
pub async fn secret_templates_service_update_secret_template_password_type(configuration: &configuration::Configuration, template_id: i32, args: Option<models::SecretTemplatePasswordTypeUpdateArgs>) -> Result<models::SecretTemplateModel, Error<SecretTemplatesServiceUpdateSecretTemplatePasswordTypeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_template_id = template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-templates/password-type/{templateId}", configuration.base_path, templateId=p_path_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretTemplatesServiceUpdateSecretTemplatePasswordTypeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

