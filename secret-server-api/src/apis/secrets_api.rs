/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`secrets_service_change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceChangePasswordError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_check_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceCheckInError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_check_out`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceCheckOutError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_convert_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceConvertTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_create_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceCreateSecretError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceDeleteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_delete_list_field_list_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceDeleteListFieldListDefinitionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_expire`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceExpireError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_export_secret_job`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceExportSecretJobError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_export_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceExportSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_extend_check_out`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceExtendCheckOutError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_favorite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceFavoriteError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_active_secret_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetActiveSecretSessionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_all_search_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetAllSearchIdsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_convert_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetConvertInfoError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_favorites`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetFavoritesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_general`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetGeneralError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_list_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetListFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_list_field_list_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetListFieldListDefinitionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_lookup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetLookupError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_restricted`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetRestrictedError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_audits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretAuditsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_extended_search_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretExtendedSearchDetailsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_import_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretImportConfigurationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretPreviewError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_rdp_proxy_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretRdpProxyInfoError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretSettingsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_ssh_proxy_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretSshProxyInfoError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_ssh_terminal_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretSshTerminalDetailsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretStateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_state_flags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretStateFlagsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_transition_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretTransitionHistoryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_secret_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSecretV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_ssh_restricted_commands`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSshRestrictedCommandsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_get_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceGetSummaryError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_import_csv_process`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceImportCsvProcessError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_import_csv_verify`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceImportCsvVerifyError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_import_xml_process`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceImportXmlProcessError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_put_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServicePutFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_restricted_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceRestrictedFieldError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_retrieve_export_secrets_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceRetrieveExportSecretsDetailsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_retrieve_secret_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceRetrieveSecretExportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_retrieve_secret_job_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceRetrieveSecretJobStatusError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_run_heart_beat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceRunHeartBeatError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_search_secret_lookup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceSearchSecretLookupError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_search_total_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceSearchTotalV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_search_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceSearchV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_stop_password_change`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceStopPasswordChangeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_stub`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceStubError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_undelete_secret_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUndeleteSecretV3Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateEmailError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_email_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateEmailV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_expiration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateExpirationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_general`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateGeneralError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_general_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateGeneralV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_jumpbox_route_selection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateJumpboxRouteSelectionError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_list_field_list_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateListFieldListDefinitionsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_rpc_script_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateRpcScriptSecretsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_rpc_script_secrets_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateRpcScriptSecretsV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecretError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_secret_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecretSessionError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_security`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecurityError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_security_approval_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecurityApprovalV3Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_security_checkout_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecurityCheckoutV3Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_security_multifactor_authentication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecurityMultifactorAuthenticationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_security_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSecurityV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_service_update_ssh_restricted_commands`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsServiceUpdateSshRestrictedCommandsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Change a secret's password
pub async fn secrets_service_change_password(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, change_password_args: Option<models::SecretChangePasswordArgs>) -> Result<models::SecretSummary, Error<SecretsServiceChangePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_change_password_args = change_password_args;

    let uri_str = format!("{}/v1/secrets/{id}/change-password", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_change_password_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceChangePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check in a secret. Checking a secret ends exclusive access to the secret and allows other users to check-out and view or edit it.
pub async fn secrets_service_check_in(configuration: &configuration::Configuration, id: i32, secret_path: Option<&str>, restricted_args: Option<models::SecretRestrictedArgs>) -> Result<models::SecretSummary, Error<SecretsServiceCheckInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_secret_path = secret_path;
    let p_body_restricted_args = restricted_args;

    let uri_str = format!("{}/v1/secrets/{id}/check-in", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_restricted_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceCheckInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check Out a secret
pub async fn secrets_service_check_out(configuration: &configuration::Configuration, id: i32, secret_path: Option<&str>) -> Result<models::SecretResponseCodeModel, Error<SecretsServiceCheckOutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/check-out", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretResponseCodeModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretResponseCodeModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceCheckOutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Convert the specificed Secrets to a different Secret Template
pub async fn secrets_service_convert_template(configuration: &configuration::Configuration, args: Option<models::SecretDetailConvertTemplateArgs>) -> Result<models::SecretDetailConvertTemplateModel, Error<SecretsServiceConvertTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/convert-template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailConvertTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailConvertTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceConvertTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new secret
pub async fn secrets_service_create_secret(configuration: &configuration::Configuration, secret_create_args: Option<models::SecretCreateArgs>) -> Result<models::SecretModel, Error<SecretsServiceCreateSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_secret_create_args = secret_create_args;

    let uri_str = format!("{}/v1/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_secret_create_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceCreateSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A deactivated secret is hidden from users who do not have a role containing the View Inactive Secrets permission. Secret Server uses these \"soft deletes\" to maintain the audit history for all data. However, deactivated secrets are still accessible by administrators (like a permanent Recycle Bin) to ensure that audit history is maintained and to support recovery. A user must have the \"View Inactive Secrets\" permission in addition to Owner permission on a secret to access the secret View page for a deleted secret. To permanently remove all information on a secret, use the \"Erase Secret\" function.
pub async fn secrets_service_delete(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::DeletedModel, Error<SecretsServiceDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeletedModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeletedModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the lists associated to a secret list data field
pub async fn secrets_service_delete_list_field_list_definitions(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, list_guid: Option<&str>) -> Result<models::PagingOfCategorizedListSummary, Error<SecretsServiceDeleteListFieldListDefinitionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_list_guid = list_guid;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}/listdetails", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_list_guid {
        req_builder = req_builder.query(&[("listGuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceDeleteListFieldListDefinitionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Expire a secret
pub async fn secrets_service_expire(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, restricted_args: Option<models::SecretRestrictedArgs>) -> Result<models::SecretSummary, Error<SecretsServiceExpireError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_restricted_args = restricted_args;

    let uri_str = format!("{}/v1/secrets/{id}/expire", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_restricted_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceExpireError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Export Secrets File Job Creation
pub async fn secrets_service_export_secret_job(configuration: &configuration::Configuration, args: Option<models::ExportSecretsArgs>) -> Result<models::ExportSecretsJobResultModel, Error<SecretsServiceExportSecretJobError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v2/secrets/export/job", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExportSecretsJobResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExportSecretsJobResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceExportSecretJobError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exports secrets
pub async fn secrets_service_export_secrets(configuration: &configuration::Configuration, args: Option<models::ExportSecretsArgs>) -> Result<models::SecretsExportResultModel, Error<SecretsServiceExportSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/export", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsExportResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsExportResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceExportSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Extend remaining check out time.
pub async fn secrets_service_extend_check_out(configuration: &configuration::Configuration, id: i32, args: Option<models::SecretCheckOutExtensionArgs>) -> Result<models::SecretCheckOutExtensionResponseModel, Error<SecretsServiceExtendCheckOutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/extend-check-out", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretCheckOutExtensionResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretCheckOutExtensionResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceExtendCheckOutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Used to favorite or unfavorite an individual Secret
pub async fn secrets_service_favorite(configuration: &configuration::Configuration, secret_id: i32, secret_path: Option<&str>, args: Option<models::FavoriteSecretArgs>) -> Result<bool, Error<SecretsServiceFavoriteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_id = secret_id;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{secretId}/favorite", configuration.base_path, secretId=p_path_secret_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceFavoriteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get secret launcher sessions
pub async fn secrets_service_get_active_secret_sessions(configuration: &configuration::Configuration, filter_secret_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretLauncherSessionSummary, Error<SecretsServiceGetActiveSecretSessionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_secret_id = filter_secret_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secrets/launcher-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_secret_id {
        req_builder = req_builder.query(&[("filter.secretId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretLauncherSessionSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretLauncherSessionSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetActiveSecretSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return all secret IDs matching the search query
pub async fn secrets_service_get_all_search_ids(configuration: &configuration::Configuration, filter_allow_double_locks: Option<bool>, filter_do_not_calculate_total: Option<bool>, filter_double_lock_id: Option<i32>, filter_extended_fields: Option<Vec<String>>, filter_extended_type_id: Option<i32>, filter_ext_fields_combined: Option<&str>, filter_folder_id: Option<i32>, filter_has_launcher: Option<bool>, filter_heartbeat_status: Option<&str>, filter_include_active: Option<bool>, filter_include_inactive: Option<bool>, filter_include_restricted: Option<bool>, filter_include_sub_folders: Option<bool>, filter_is_exact_match: Option<bool>, filter_only_checked_out_secrets: Option<bool>, filter_only_rpc_enabled: Option<bool>, filter_only_secrets_checked_out_by_user: Option<bool>, filter_only_shared_with_me: Option<bool>, filter_password_type_ids: Option<Vec<i32>>, filter_permission_required: Option<&str>, filter_recent_max_date_time: Option<String>, filter_recent_min_date_time: Option<String>, filter_scope: Option<&str>, filter_search_field: Option<&str>, filter_search_field_slug: Option<&str>, filter_search_text: Option<&str>, filter_secret_ids: Option<Vec<i32>>, filter_secret_template_ids: Option<Vec<i32>>, filter_secret_template_ids_combined: Option<&str>, filter_site_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<Vec<i32>, Error<SecretsServiceGetAllSearchIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_allow_double_locks = filter_allow_double_locks;
    let p_query_filter_do_not_calculate_total = filter_do_not_calculate_total;
    let p_query_filter_double_lock_id = filter_double_lock_id;
    let p_query_filter_extended_fields = filter_extended_fields;
    let p_query_filter_extended_type_id = filter_extended_type_id;
    let p_query_filter_ext_fields_combined = filter_ext_fields_combined;
    let p_query_filter_folder_id = filter_folder_id;
    let p_query_filter_has_launcher = filter_has_launcher;
    let p_query_filter_heartbeat_status = filter_heartbeat_status;
    let p_query_filter_include_active = filter_include_active;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_restricted = filter_include_restricted;
    let p_query_filter_include_sub_folders = filter_include_sub_folders;
    let p_query_filter_is_exact_match = filter_is_exact_match;
    let p_query_filter_only_checked_out_secrets = filter_only_checked_out_secrets;
    let p_query_filter_only_rpc_enabled = filter_only_rpc_enabled;
    let p_query_filter_only_secrets_checked_out_by_user = filter_only_secrets_checked_out_by_user;
    let p_query_filter_only_shared_with_me = filter_only_shared_with_me;
    let p_query_filter_password_type_ids = filter_password_type_ids;
    let p_query_filter_permission_required = filter_permission_required;
    let p_query_filter_recent_max_date_time = filter_recent_max_date_time;
    let p_query_filter_recent_min_date_time = filter_recent_min_date_time;
    let p_query_filter_scope = filter_scope;
    let p_query_filter_search_field = filter_search_field;
    let p_query_filter_search_field_slug = filter_search_field_slug;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_secret_ids = filter_secret_ids;
    let p_query_filter_secret_template_ids = filter_secret_template_ids;
    let p_query_filter_secret_template_ids_combined = filter_secret_template_ids_combined;
    let p_query_filter_site_id = filter_site_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secrets/search-for-ids", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_allow_double_locks {
        req_builder = req_builder.query(&[("filter.allowDoubleLocks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_do_not_calculate_total {
        req_builder = req_builder.query(&[("filter.doNotCalculateTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_double_lock_id {
        req_builder = req_builder.query(&[("filter.doubleLockId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_extended_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.extendedFields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.extendedFields", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_extended_type_id {
        req_builder = req_builder.query(&[("filter.extendedTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ext_fields_combined {
        req_builder = req_builder.query(&[("filter.extFieldsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_folder_id {
        req_builder = req_builder.query(&[("filter.folderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_has_launcher {
        req_builder = req_builder.query(&[("filter.hasLauncher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_heartbeat_status {
        req_builder = req_builder.query(&[("filter.heartbeatStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_active {
        req_builder = req_builder.query(&[("filter.includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_restricted {
        req_builder = req_builder.query(&[("filter.includeRestricted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_sub_folders {
        req_builder = req_builder.query(&[("filter.includeSubFolders", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_is_exact_match {
        req_builder = req_builder.query(&[("filter.isExactMatch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_checked_out_secrets {
        req_builder = req_builder.query(&[("filter.onlyCheckedOutSecrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_rpc_enabled {
        req_builder = req_builder.query(&[("filter.onlyRPCEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_secrets_checked_out_by_user {
        req_builder = req_builder.query(&[("filter.onlySecretsCheckedOutByUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_shared_with_me {
        req_builder = req_builder.query(&[("filter.onlySharedWithMe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_password_type_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.passwordTypeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.passwordTypeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_permission_required {
        req_builder = req_builder.query(&[("filter.permissionRequired", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_max_date_time {
        req_builder = req_builder.query(&[("filter.recentMaxDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_min_date_time {
        req_builder = req_builder.query(&[("filter.recentMinDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scope {
        req_builder = req_builder.query(&[("filter.scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field {
        req_builder = req_builder.query(&[("filter.searchField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field_slug {
        req_builder = req_builder.query(&[("filter.searchFieldSlug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_secret_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretTemplateIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretTemplateIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids_combined {
        req_builder = req_builder.query(&[("filter.secretTemplateIdsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_site_id {
        req_builder = req_builder.query(&[("filter.siteId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetAllSearchIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve information about the requested conversion such as which fields exist on the target template.
pub async fn secrets_service_get_convert_info(configuration: &configuration::Configuration, args: Option<models::SecretDetailConvertTemplateInfoArgs>) -> Result<models::ConvertTemplateDetailsModel, Error<SecretsServiceGetConvertInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/get-convert-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConvertTemplateDetailsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConvertTemplateDetailsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetConvertInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of secrets which the user has favorited.
pub async fn secrets_service_get_favorites(configuration: &configuration::Configuration, ) -> Result<Vec<models::WidgetSecretModel>, Error<SecretsServiceGetFavoritesError>> {

    let uri_str = format!("{}/v1/secrets/favorite", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WidgetSecretModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WidgetSecretModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetFavoritesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a secret data field
pub async fn secrets_service_get_field(configuration: &configuration::Configuration, id: i32, slug: &str, include_inactive: Option<bool>, no_auto_checkout: Option<bool>, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<String, Error<SecretsServiceGetFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_include_inactive = include_inactive;
    let p_query_no_auto_checkout = no_auto_checkout;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_inactive {
        req_builder = req_builder.query(&[("includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_auto_checkout {
        req_builder = req_builder.query(&[("noAutoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve details about a secret.
pub async fn secrets_service_get_general(configuration: &configuration::Configuration, id: i32, is_edit_mode: Option<bool>, load_read_only_flags: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretDetailGeneralModel, Error<SecretsServiceGetGeneralError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_is_edit_mode = is_edit_mode;
    let p_query_load_read_only_flags = load_read_only_flags;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/secret-detail/{id}/general", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_edit_mode {
        req_builder = req_builder.query(&[("isEditMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_load_read_only_flags {
        req_builder = req_builder.query(&[("loadReadOnlyFlags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailGeneralModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailGeneralModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetGeneralError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the items associated to a secret list data field
pub async fn secrets_service_get_list_field(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>) -> Result<models::CategorizedListItemValueResult, Error<SecretsServiceGetListFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}/list", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CategorizedListItemValueResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CategorizedListItemValueResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetListFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the lists associated to a secret list data field
pub async fn secrets_service_get_list_field_list_definitions(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfCategorizedListSummary, Error<SecretsServiceGetListFieldListDefinitionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}/listdetails", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetListFieldListDefinitionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Look up secret by ID and return secret name and ID
pub async fn secrets_service_get_lookup(configuration: &configuration::Configuration, id: i32, secret_path: Option<&str>) -> Result<models::SecretLookup, Error<SecretsServiceGetLookupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/lookup/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretLookup`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretLookup`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetLookupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a restricted secret
pub async fn secrets_service_get_restricted(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretRestrictedArgs>) -> Result<models::SecretModel, Error<SecretsServiceGetRestrictedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/restricted", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetRestrictedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get audits for a particular Secret for the given filter.
pub async fn secrets_service_get_secret_audits(configuration: &configuration::Configuration, id: i32, is_exporting: Option<bool>, filter_audit_actions: Option<&str>, filter_include_password_change_log: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>, secret_path: Option<&str>) -> Result<models::PagingOfSecretAuditModel, Error<SecretsServiceGetSecretAuditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_is_exporting = is_exporting;
    let p_query_filter_audit_actions = filter_audit_actions;
    let p_query_filter_include_password_change_log = filter_include_password_change_log;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/audits", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_exporting {
        req_builder = req_builder.query(&[("isExporting", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_audit_actions {
        req_builder = req_builder.query(&[("filter.auditActions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_password_change_log {
        req_builder = req_builder.query(&[("filter.includePasswordChangeLog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretAuditModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretAuditModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretAuditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Pass an array of secret IDs, presumably the results of a secret search and get extended details such as has launchers or is favorite.
pub async fn secrets_service_get_secret_extended_search_details(configuration: &configuration::Configuration, args: Option<models::SecretSearchExtendedArgs>) -> Result<Vec<models::SecretSearchExtendedSummary>, Error<SecretsServiceGetSecretExtendedSearchDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/extended-search-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SecretSearchExtendedSummary&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SecretSearchExtendedSummary&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretExtendedSearchDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return settings that are allowed for secret import
pub async fn secrets_service_get_secret_import_configuration(configuration: &configuration::Configuration, ) -> Result<models::SecretImportConfigurationModel, Error<SecretsServiceGetSecretImportConfigurationError>> {

    let uri_str = format!("{}/v1/secrets/import-configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretImportConfigurationModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretImportConfigurationModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretImportConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a preview of an unrestricted secret by ID. Restricted secrets will return an AccessDeniedException.
pub async fn secrets_service_get_secret_preview(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::DashboardViewSecret, Error<SecretsServiceGetSecretPreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/preview", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DashboardViewSecret`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DashboardViewSecret`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretPreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get RDP Proxy Information
pub async fn secrets_service_get_secret_rdp_proxy_info(configuration: &configuration::Configuration, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, args: Option<models::SecretProxyArgs>) -> Result<models::SecretRdpProxyModel, Error<SecretsServiceGetSecretRdpProxyInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/rdpproxy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretRdpProxyModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretRdpProxyModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretRdpProxyInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Secret Settings
pub async fn secrets_service_get_secret_settings(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretDetailSettingsModel, Error<SecretsServiceGetSecretSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/settings", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSettingsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSettingsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get SSH Proxy Information
pub async fn secrets_service_get_secret_ssh_proxy_info(configuration: &configuration::Configuration, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, args: Option<models::SecretProxyArgs>) -> Result<models::SecretSshProxyModel, Error<SecretsServiceGetSecretSshProxyInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/sshproxy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSshProxyModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSshProxyModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretSshProxyInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get SSH Terminal Details
pub async fn secrets_service_get_secret_ssh_terminal_details(configuration: &configuration::Configuration, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, args: Option<models::SecretSshTerminalArgs>) -> Result<models::SecretSshTerminalModel, Error<SecretsServiceGetSecretSshTerminalDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/sshterminal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSshTerminalModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSshTerminalModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretSshTerminalDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve state about a Secret such as whether it requires approval, doublelock, checkout, or other restricted actions to be performed before calling the get the secret.
pub async fn secrets_service_get_secret_state(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretDetailStateViewModel, Error<SecretsServiceGetSecretStateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/state", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailStateViewModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailStateViewModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretStateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve state flags about a Secret, such as heartbeatStatus, passwordCompliance, or other states to be displayed inside a conditional chip.
pub async fn secrets_service_get_secret_state_flags(configuration: &configuration::Configuration, id: i32) -> Result<models::SecretStateFlagsModel, Error<SecretsServiceGetSecretStateFlagsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/secrets/{id}/state/flags", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretStateFlagsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretStateFlagsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretStateFlagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the secret password that will be used next during an actual rotation.
pub async fn secrets_service_get_secret_transition_history(configuration: &configuration::Configuration, secret_id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretTransitionHistorySummaryModel, Error<SecretsServiceGetSecretTransitionHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_id = secret_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secrets/{secretId}/transition-history", configuration.base_path, secretId=p_path_secret_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretTransitionHistorySummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretTransitionHistorySummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretTransitionHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a single secret by ID
pub async fn secrets_service_get_secret_v2(configuration: &configuration::Configuration, id: i32, include_inactive: Option<bool>, no_auto_checkout: Option<bool>, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretModelV2, Error<SecretsServiceGetSecretV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_include_inactive = include_inactive;
    let p_query_no_auto_checkout = no_auto_checkout;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v2/secrets/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_inactive {
        req_builder = req_builder.query(&[("includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_auto_checkout {
        req_builder = req_builder.query(&[("noAutoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretModelV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretModelV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSecretV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the SSH command restrictions for a Secret
pub async fn secrets_service_get_ssh_restricted_commands(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>) -> Result<models::SecretDetailRestrictedSshCommandViewModel, Error<SecretsServiceGetSshRestrictedCommandsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;

    let uri_str = format!("{}/v1/secrets/{id}/ssh-restricted-commands", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailRestrictedSshCommandViewModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailRestrictedSshCommandViewModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSshRestrictedCommandsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the summary for a secret
pub async fn secrets_service_get_summary(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretSummary, Error<SecretsServiceGetSummaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/summary", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceGetSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start to process a CSV import.
pub async fn secrets_service_import_csv_process(configuration: &configuration::Configuration, args: Option<models::SecretImportCsvProcessArgs>) -> Result<models::SecretImportCsvProcessModel, Error<SecretsServiceImportCsvProcessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/import-csv-process", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretImportCsvProcessModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretImportCsvProcessModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceImportCsvProcessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload a CSV list of secrets and get a response that allows you to verify the import before processing it.
pub async fn secrets_service_import_csv_verify(configuration: &configuration::Configuration, args: Option<models::SecretImportCsvVerifyArgs>) -> Result<models::SecretImportCsvVerifyModel, Error<SecretsServiceImportCsvVerifyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/import-csv-verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretImportCsvVerifyModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretImportCsvVerifyModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceImportCsvVerifyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start to process a XML import.
pub async fn secrets_service_import_xml_process(configuration: &configuration::Configuration, args: Option<models::SecretImportXmlProcessArgs>) -> Result<models::SecretImportXmlProcessResultModel, Error<SecretsServiceImportXmlProcessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/import-xml-process", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretImportXmlProcessResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretImportXmlProcessResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceImportXmlProcessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a secret data field
pub async fn secrets_service_put_field(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretItemUpdateArgs>) -> Result<String, Error<SecretsServicePutFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServicePutFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a restricted secret data field
pub async fn secrets_service_restricted_field(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretRestrictedArgs>) -> Result<String, Error<SecretsServiceRestrictedFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/restricted/fields/{slug}", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceRestrictedFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exports Secret Job Details
pub async fn secrets_service_retrieve_export_secrets_details(configuration: &configuration::Configuration, job_id: &str) -> Result<models::ExportSecretsExportJobDetails, Error<SecretsServiceRetrieveExportSecretsDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_id = job_id;

    let uri_str = format!("{}/v2/secrets/export/{jobId}/details", configuration.base_path, jobId=crate::apis::urlencode(p_path_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExportSecretsExportJobDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExportSecretsExportJobDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceRetrieveExportSecretsDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exports Secrets from Storage
pub async fn secrets_service_retrieve_secret_export(configuration: &configuration::Configuration, job_id: Option<&str>) -> Result<models::ExportSecretsResultModelV2, Error<SecretsServiceRetrieveSecretExportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_job_id = job_id;

    let uri_str = format!("{}/v2/secrets/export", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_job_id {
        req_builder = req_builder.query(&[("jobId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExportSecretsResultModelV2`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExportSecretsResultModelV2`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceRetrieveSecretExportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exports secrets Job Status
pub async fn secrets_service_retrieve_secret_job_status(configuration: &configuration::Configuration, job_id: &str) -> Result<models::ExportSecretsJobResultModel, Error<SecretsServiceRetrieveSecretJobStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_job_id = job_id;

    let uri_str = format!("{}/v2/secrets/export/job/{jobId}", configuration.base_path, jobId=crate::apis::urlencode(p_path_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExportSecretsJobResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExportSecretsJobResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceRetrieveSecretJobStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check if secret is still valid
pub async fn secrets_service_run_heart_beat(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>) -> Result<models::SecretSummary, Error<SecretsServiceRunHeartBeatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/heartbeat", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceRunHeartBeatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page secrets, returning only secret ID and name
pub async fn secrets_service_search_secret_lookup(configuration: &configuration::Configuration, filter_allow_double_locks: Option<bool>, filter_do_not_calculate_total: Option<bool>, filter_double_lock_id: Option<i32>, filter_extended_fields: Option<Vec<String>>, filter_extended_type_id: Option<i32>, filter_folder_id: Option<i32>, filter_heartbeat_status: Option<&str>, filter_include_active: Option<bool>, filter_include_inactive: Option<bool>, filter_include_restricted: Option<bool>, filter_include_sub_folders: Option<bool>, filter_is_exact_match: Option<bool>, filter_only_rpc_enabled: Option<bool>, filter_only_secrets_checked_out_by_user: Option<bool>, filter_only_shared_with_me: Option<bool>, filter_password_type_ids: Option<Vec<i32>>, filter_permission_required: Option<&str>, filter_recent_max_date_time: Option<String>, filter_recent_min_date_time: Option<String>, filter_scope: Option<&str>, filter_search_field: Option<&str>, filter_search_field_slug: Option<&str>, filter_search_text: Option<&str>, filter_secret_template_id: Option<i32>, filter_site_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretLookup, Error<SecretsServiceSearchSecretLookupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_allow_double_locks = filter_allow_double_locks;
    let p_query_filter_do_not_calculate_total = filter_do_not_calculate_total;
    let p_query_filter_double_lock_id = filter_double_lock_id;
    let p_query_filter_extended_fields = filter_extended_fields;
    let p_query_filter_extended_type_id = filter_extended_type_id;
    let p_query_filter_folder_id = filter_folder_id;
    let p_query_filter_heartbeat_status = filter_heartbeat_status;
    let p_query_filter_include_active = filter_include_active;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_restricted = filter_include_restricted;
    let p_query_filter_include_sub_folders = filter_include_sub_folders;
    let p_query_filter_is_exact_match = filter_is_exact_match;
    let p_query_filter_only_rpc_enabled = filter_only_rpc_enabled;
    let p_query_filter_only_secrets_checked_out_by_user = filter_only_secrets_checked_out_by_user;
    let p_query_filter_only_shared_with_me = filter_only_shared_with_me;
    let p_query_filter_password_type_ids = filter_password_type_ids;
    let p_query_filter_permission_required = filter_permission_required;
    let p_query_filter_recent_max_date_time = filter_recent_max_date_time;
    let p_query_filter_recent_min_date_time = filter_recent_min_date_time;
    let p_query_filter_scope = filter_scope;
    let p_query_filter_search_field = filter_search_field;
    let p_query_filter_search_field_slug = filter_search_field_slug;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_secret_template_id = filter_secret_template_id;
    let p_query_filter_site_id = filter_site_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/secrets/lookup", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_allow_double_locks {
        req_builder = req_builder.query(&[("filter.allowDoubleLocks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_do_not_calculate_total {
        req_builder = req_builder.query(&[("filter.doNotCalculateTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_double_lock_id {
        req_builder = req_builder.query(&[("filter.doubleLockId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_extended_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.extendedFields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.extendedFields", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_extended_type_id {
        req_builder = req_builder.query(&[("filter.extendedTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_folder_id {
        req_builder = req_builder.query(&[("filter.folderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_heartbeat_status {
        req_builder = req_builder.query(&[("filter.heartbeatStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_active {
        req_builder = req_builder.query(&[("filter.includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_restricted {
        req_builder = req_builder.query(&[("filter.includeRestricted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_sub_folders {
        req_builder = req_builder.query(&[("filter.includeSubFolders", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_is_exact_match {
        req_builder = req_builder.query(&[("filter.isExactMatch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_rpc_enabled {
        req_builder = req_builder.query(&[("filter.onlyRPCEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_secrets_checked_out_by_user {
        req_builder = req_builder.query(&[("filter.onlySecretsCheckedOutByUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_shared_with_me {
        req_builder = req_builder.query(&[("filter.onlySharedWithMe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_password_type_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.passwordTypeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.passwordTypeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_permission_required {
        req_builder = req_builder.query(&[("filter.permissionRequired", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_max_date_time {
        req_builder = req_builder.query(&[("filter.recentMaxDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_min_date_time {
        req_builder = req_builder.query(&[("filter.recentMinDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scope {
        req_builder = req_builder.query(&[("filter.scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field {
        req_builder = req_builder.query(&[("filter.searchField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field_slug {
        req_builder = req_builder.query(&[("filter.searchFieldSlug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_secret_template_id {
        req_builder = req_builder.query(&[("filter.secretTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_site_id {
        req_builder = req_builder.query(&[("filter.siteId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretLookup`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretLookup`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceSearchSecretLookupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the total number of secrets matching the secret search filter
pub async fn secrets_service_search_total_v2(configuration: &configuration::Configuration, filter_allow_double_locks: Option<bool>, filter_do_not_calculate_total: Option<bool>, filter_double_lock_id: Option<i32>, filter_extended_fields: Option<Vec<String>>, filter_extended_type_id: Option<i32>, filter_ext_fields_combined: Option<&str>, filter_folder_id: Option<i32>, filter_has_launcher: Option<bool>, filter_heartbeat_status: Option<&str>, filter_include_active: Option<bool>, filter_include_inactive: Option<bool>, filter_include_restricted: Option<bool>, filter_include_sub_folders: Option<bool>, filter_is_exact_match: Option<bool>, filter_only_checked_out_secrets: Option<bool>, filter_only_rpc_enabled: Option<bool>, filter_only_secrets_checked_out_by_user: Option<bool>, filter_only_shared_with_me: Option<bool>, filter_password_type_ids: Option<Vec<i32>>, filter_permission_required: Option<&str>, filter_recent_max_date_time: Option<String>, filter_recent_min_date_time: Option<String>, filter_scope: Option<&str>, filter_search_field: Option<&str>, filter_search_field_slug: Option<&str>, filter_search_text: Option<&str>, filter_secret_ids: Option<Vec<i32>>, filter_secret_template_ids: Option<Vec<i32>>, filter_secret_template_ids_combined: Option<&str>, filter_site_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<i32, Error<SecretsServiceSearchTotalV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_allow_double_locks = filter_allow_double_locks;
    let p_query_filter_do_not_calculate_total = filter_do_not_calculate_total;
    let p_query_filter_double_lock_id = filter_double_lock_id;
    let p_query_filter_extended_fields = filter_extended_fields;
    let p_query_filter_extended_type_id = filter_extended_type_id;
    let p_query_filter_ext_fields_combined = filter_ext_fields_combined;
    let p_query_filter_folder_id = filter_folder_id;
    let p_query_filter_has_launcher = filter_has_launcher;
    let p_query_filter_heartbeat_status = filter_heartbeat_status;
    let p_query_filter_include_active = filter_include_active;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_restricted = filter_include_restricted;
    let p_query_filter_include_sub_folders = filter_include_sub_folders;
    let p_query_filter_is_exact_match = filter_is_exact_match;
    let p_query_filter_only_checked_out_secrets = filter_only_checked_out_secrets;
    let p_query_filter_only_rpc_enabled = filter_only_rpc_enabled;
    let p_query_filter_only_secrets_checked_out_by_user = filter_only_secrets_checked_out_by_user;
    let p_query_filter_only_shared_with_me = filter_only_shared_with_me;
    let p_query_filter_password_type_ids = filter_password_type_ids;
    let p_query_filter_permission_required = filter_permission_required;
    let p_query_filter_recent_max_date_time = filter_recent_max_date_time;
    let p_query_filter_recent_min_date_time = filter_recent_min_date_time;
    let p_query_filter_scope = filter_scope;
    let p_query_filter_search_field = filter_search_field;
    let p_query_filter_search_field_slug = filter_search_field_slug;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_secret_ids = filter_secret_ids;
    let p_query_filter_secret_template_ids = filter_secret_template_ids;
    let p_query_filter_secret_template_ids_combined = filter_secret_template_ids_combined;
    let p_query_filter_site_id = filter_site_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v2/secrets/search-total", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_allow_double_locks {
        req_builder = req_builder.query(&[("filter.allowDoubleLocks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_do_not_calculate_total {
        req_builder = req_builder.query(&[("filter.doNotCalculateTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_double_lock_id {
        req_builder = req_builder.query(&[("filter.doubleLockId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_extended_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.extendedFields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.extendedFields", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_extended_type_id {
        req_builder = req_builder.query(&[("filter.extendedTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ext_fields_combined {
        req_builder = req_builder.query(&[("filter.extFieldsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_folder_id {
        req_builder = req_builder.query(&[("filter.folderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_has_launcher {
        req_builder = req_builder.query(&[("filter.hasLauncher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_heartbeat_status {
        req_builder = req_builder.query(&[("filter.heartbeatStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_active {
        req_builder = req_builder.query(&[("filter.includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_restricted {
        req_builder = req_builder.query(&[("filter.includeRestricted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_sub_folders {
        req_builder = req_builder.query(&[("filter.includeSubFolders", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_is_exact_match {
        req_builder = req_builder.query(&[("filter.isExactMatch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_checked_out_secrets {
        req_builder = req_builder.query(&[("filter.onlyCheckedOutSecrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_rpc_enabled {
        req_builder = req_builder.query(&[("filter.onlyRPCEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_secrets_checked_out_by_user {
        req_builder = req_builder.query(&[("filter.onlySecretsCheckedOutByUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_shared_with_me {
        req_builder = req_builder.query(&[("filter.onlySharedWithMe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_password_type_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.passwordTypeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.passwordTypeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_permission_required {
        req_builder = req_builder.query(&[("filter.permissionRequired", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_max_date_time {
        req_builder = req_builder.query(&[("filter.recentMaxDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_min_date_time {
        req_builder = req_builder.query(&[("filter.recentMinDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scope {
        req_builder = req_builder.query(&[("filter.scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field {
        req_builder = req_builder.query(&[("filter.searchField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field_slug {
        req_builder = req_builder.query(&[("filter.searchFieldSlug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_secret_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretTemplateIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretTemplateIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids_combined {
        req_builder = req_builder.query(&[("filter.secretTemplateIdsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_site_id {
        req_builder = req_builder.query(&[("filter.siteId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceSearchTotalV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search, filter, sort, and page secrets
pub async fn secrets_service_search_v2(configuration: &configuration::Configuration, filter_allow_double_locks: Option<bool>, filter_do_not_calculate_total: Option<bool>, filter_double_lock_id: Option<i32>, filter_extended_fields: Option<Vec<String>>, filter_extended_type_id: Option<i32>, filter_ext_fields_combined: Option<&str>, filter_folder_id: Option<i32>, filter_has_launcher: Option<bool>, filter_heartbeat_status: Option<&str>, filter_include_active: Option<bool>, filter_include_inactive: Option<bool>, filter_include_restricted: Option<bool>, filter_include_sub_folders: Option<bool>, filter_is_exact_match: Option<bool>, filter_only_checked_out_secrets: Option<bool>, filter_only_rpc_enabled: Option<bool>, filter_only_secrets_checked_out_by_user: Option<bool>, filter_only_shared_with_me: Option<bool>, filter_password_type_ids: Option<Vec<i32>>, filter_permission_required: Option<&str>, filter_recent_max_date_time: Option<String>, filter_recent_min_date_time: Option<String>, filter_scope: Option<&str>, filter_search_field: Option<&str>, filter_search_field_slug: Option<&str>, filter_search_text: Option<&str>, filter_secret_ids: Option<Vec<i32>>, filter_secret_template_ids: Option<Vec<i32>>, filter_secret_template_ids_combined: Option<&str>, filter_site_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfSecretSummary, Error<SecretsServiceSearchV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_allow_double_locks = filter_allow_double_locks;
    let p_query_filter_do_not_calculate_total = filter_do_not_calculate_total;
    let p_query_filter_double_lock_id = filter_double_lock_id;
    let p_query_filter_extended_fields = filter_extended_fields;
    let p_query_filter_extended_type_id = filter_extended_type_id;
    let p_query_filter_ext_fields_combined = filter_ext_fields_combined;
    let p_query_filter_folder_id = filter_folder_id;
    let p_query_filter_has_launcher = filter_has_launcher;
    let p_query_filter_heartbeat_status = filter_heartbeat_status;
    let p_query_filter_include_active = filter_include_active;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_filter_include_restricted = filter_include_restricted;
    let p_query_filter_include_sub_folders = filter_include_sub_folders;
    let p_query_filter_is_exact_match = filter_is_exact_match;
    let p_query_filter_only_checked_out_secrets = filter_only_checked_out_secrets;
    let p_query_filter_only_rpc_enabled = filter_only_rpc_enabled;
    let p_query_filter_only_secrets_checked_out_by_user = filter_only_secrets_checked_out_by_user;
    let p_query_filter_only_shared_with_me = filter_only_shared_with_me;
    let p_query_filter_password_type_ids = filter_password_type_ids;
    let p_query_filter_permission_required = filter_permission_required;
    let p_query_filter_recent_max_date_time = filter_recent_max_date_time;
    let p_query_filter_recent_min_date_time = filter_recent_min_date_time;
    let p_query_filter_scope = filter_scope;
    let p_query_filter_search_field = filter_search_field;
    let p_query_filter_search_field_slug = filter_search_field_slug;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_secret_ids = filter_secret_ids;
    let p_query_filter_secret_template_ids = filter_secret_template_ids;
    let p_query_filter_secret_template_ids_combined = filter_secret_template_ids_combined;
    let p_query_filter_site_id = filter_site_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v2/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_allow_double_locks {
        req_builder = req_builder.query(&[("filter.allowDoubleLocks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_do_not_calculate_total {
        req_builder = req_builder.query(&[("filter.doNotCalculateTotal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_double_lock_id {
        req_builder = req_builder.query(&[("filter.doubleLockId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_extended_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.extendedFields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.extendedFields", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_extended_type_id {
        req_builder = req_builder.query(&[("filter.extendedTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ext_fields_combined {
        req_builder = req_builder.query(&[("filter.extFieldsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_folder_id {
        req_builder = req_builder.query(&[("filter.folderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_has_launcher {
        req_builder = req_builder.query(&[("filter.hasLauncher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_heartbeat_status {
        req_builder = req_builder.query(&[("filter.heartbeatStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_active {
        req_builder = req_builder.query(&[("filter.includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_restricted {
        req_builder = req_builder.query(&[("filter.includeRestricted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_sub_folders {
        req_builder = req_builder.query(&[("filter.includeSubFolders", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_is_exact_match {
        req_builder = req_builder.query(&[("filter.isExactMatch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_checked_out_secrets {
        req_builder = req_builder.query(&[("filter.onlyCheckedOutSecrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_rpc_enabled {
        req_builder = req_builder.query(&[("filter.onlyRPCEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_secrets_checked_out_by_user {
        req_builder = req_builder.query(&[("filter.onlySecretsCheckedOutByUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_shared_with_me {
        req_builder = req_builder.query(&[("filter.onlySharedWithMe", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_password_type_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.passwordTypeIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.passwordTypeIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_permission_required {
        req_builder = req_builder.query(&[("filter.permissionRequired", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_max_date_time {
        req_builder = req_builder.query(&[("filter.recentMaxDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_recent_min_date_time {
        req_builder = req_builder.query(&[("filter.recentMinDateTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scope {
        req_builder = req_builder.query(&[("filter.scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field {
        req_builder = req_builder.query(&[("filter.searchField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_field_slug {
        req_builder = req_builder.query(&[("filter.searchFieldSlug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_secret_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("filter.secretTemplateIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("filter.secretTemplateIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_filter_secret_template_ids_combined {
        req_builder = req_builder.query(&[("filter.secretTemplateIdsCombined", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_site_id {
        req_builder = req_builder.query(&[("filter.siteId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfSecretSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfSecretSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceSearchV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Attempt to stop a password change
pub async fn secrets_service_stop_password_change(configuration: &configuration::Configuration, id: i32, secret_path: Option<&str>) -> Result<models::SecretDetailStopPasswordResultModel, Error<SecretsServiceStopPasswordChangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v1/secrets/{id}/stop-password-change", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailStopPasswordResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailStopPasswordResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceStopPasswordChangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return the default values for a new secret
pub async fn secrets_service_stub(configuration: &configuration::Configuration, secret_template_id: i32, folder_id: Option<i32>) -> Result<models::SecretModel, Error<SecretsServiceStubError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_secret_template_id = secret_template_id;
    let p_query_folder_id = folder_id;

    let uri_str = format!("{}/v1/secrets/stub", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_folder_id {
        req_builder = req_builder.query(&[("folderId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("secretTemplateId", &p_query_secret_template_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceStubError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Undelete or activate a secret that is currently marked deactivated / deleted.  If the secret is already active then this will still return true.
pub async fn secrets_service_undelete_secret_v3(configuration: &configuration::Configuration, id: i32, secret_path: Option<&str>) -> Result<models::ActivateSecretResponseModel, Error<SecretsServiceUndeleteSecretV3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_secret_path = secret_path;

    let uri_str = format!("{}/v3/secrets/{id}/activate", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivateSecretResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivateSecretResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUndeleteSecretV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update User Secret Email Settings
pub async fn secrets_service_update_email(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateEmailArgs>) -> Result<models::SecretDetailSettingsModel, Error<SecretsServiceUpdateEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/email", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSettingsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSettingsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update User Secret Email Settings
pub async fn secrets_service_update_email_v2(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateEmailArgs>) -> Result<models::SecretDetailSettingsModel, Error<SecretsServiceUpdateEmailV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v2/secrets/{id}/email", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSettingsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSettingsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateEmailV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Secret expiration
pub async fn secrets_service_update_expiration(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateExpirationArgs>) -> Result<models::SecretDetailSettingsModel, Error<SecretsServiceUpdateExpirationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/expiration", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSettingsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSettingsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateExpirationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret General Information
pub async fn secrets_service_update_general(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateGeneralArgs>) -> Result<models::SecretDetailGeneralViewModel, Error<SecretsServiceUpdateGeneralError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/general", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailGeneralViewModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailGeneralViewModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateGeneralError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret General Information
pub async fn secrets_service_update_general_v2(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateGeneralArgs>) -> Result<models::SecretDetailGeneralModel, Error<SecretsServiceUpdateGeneralV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v2/secrets/{id}/general", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailGeneralModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailGeneralModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateGeneralV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Jumpbox Route Selection
pub async fn secrets_service_update_jumpbox_route_selection(configuration: &configuration::Configuration, secret_id: i32, args: Option<models::SecretDetailJumpboxUpdateArgs>) -> Result<models::JumpboxRouteSummaryModel, Error<SecretsServiceUpdateJumpboxRouteSelectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_id = secret_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secret-detail/{secretId}/jumpbox-route-selection", configuration.base_path, secretId=p_path_secret_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JumpboxRouteSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JumpboxRouteSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateJumpboxRouteSelectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the lists associated to a secret list data field
pub async fn secrets_service_update_list_field_list_definitions(configuration: &configuration::Configuration, id: i32, slug: &str, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, args: Option<models::SecretListFieldListArgs>) -> Result<models::PagingOfCategorizedListSummary, Error<SecretsServiceUpdateListFieldListDefinitionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_slug = slug;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/fields/{slug}/listdetails", configuration.base_path, id=p_path_id, slug=crate::apis::urlencode(p_path_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfCategorizedListSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateListFieldListDefinitionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update which Secrets are available for RPC scripts
pub async fn secrets_service_update_rpc_script_secrets(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateRpcScriptSecretsArgs>) -> Result<models::SecretDetailRpcModel, Error<SecretsServiceUpdateRpcScriptSecretsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/rpc-script-secrets", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailRpcModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailRpcModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateRpcScriptSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update which Secrets are available for RPC scripts
pub async fn secrets_service_update_rpc_script_secrets_v2(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateRpcScriptSecretsArgs>) -> Result<models::SecretDetailRpcModel, Error<SecretsServiceUpdateRpcScriptSecretsV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v2/secrets/{id}/rpc-script-secrets", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailRpcModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailRpcModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateRpcScriptSecretsV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a single secret by ID
pub async fn secrets_service_update_secret(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretUpdateArgs>) -> Result<models::SecretModel, Error<SecretsServiceUpdateSecretError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update or Terminate Secret Launcher Sessions
pub async fn secrets_service_update_secret_session(configuration: &configuration::Configuration, args: Option<models::SecretLauncherSessionArgs>) -> Result<models::SecretLauncherSessionActionResult, Error<SecretsServiceUpdateSecretSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/launcher-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretLauncherSessionActionResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretLauncherSessionActionResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecretSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret Security General Options
pub async fn secrets_service_update_security(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateSecurityGeneralArgs>) -> Result<models::SecretDetailSecurityViewModel, Error<SecretsServiceUpdateSecurityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/security-general", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSecurityViewModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSecurityViewModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecurityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret Security Approval Options
pub async fn secrets_service_update_security_approval_v3(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateSecurityApprovalArgs>) -> Result<models::SecretSecurityUpdateResponse, Error<SecretsServiceUpdateSecurityApprovalV3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v3/secrets/{id}/security-approval", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSecurityUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSecurityUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecurityApprovalV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret Security Checkout Options
pub async fn secrets_service_update_security_checkout_v3(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateSecurityCheckoutArgs>) -> Result<models::SecretSecurityUpdateResponse, Error<SecretsServiceUpdateSecurityCheckoutV3Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v3/secrets/{id}/security-checkout", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretSecurityUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretSecurityUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecurityCheckoutV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret Security Multifactor Authentication Options
pub async fn secrets_service_update_security_multifactor_authentication(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateSecurityMultifactorArgs>) -> Result<models::SecretDetailSecurityModel, Error<SecretsServiceUpdateSecurityMultifactorAuthenticationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{id}/security-multifactor-authentication", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSecurityModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSecurityModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecurityMultifactorAuthenticationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update Secret Security General Options
pub async fn secrets_service_update_security_v2(configuration: &configuration::Configuration, id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, secret_path: Option<&str>, args: Option<models::SecretDetailUpdateSecurityGeneralArgs>) -> Result<models::SecretDetailSecurityModel, Error<SecretsServiceUpdateSecurityV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_query_secret_path = secret_path;
    let p_body_args = args;

    let uri_str = format!("{}/v2/secrets/{id}/security-general", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secret_path {
        req_builder = req_builder.query(&[("secretPath", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretDetailSecurityModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretDetailSecurityModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSecurityV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the restricted SSH commands configured on a Secret
pub async fn secrets_service_update_ssh_restricted_commands(configuration: &configuration::Configuration, secret_id: i32, auto_check_in: Option<bool>, auto_checkout: Option<bool>, auto_comment: Option<&str>, force_check_in: Option<bool>, args: Option<models::SecretDetailSshRestrictedCommandUpdateArgs>) -> Result<bool, Error<SecretsServiceUpdateSshRestrictedCommandsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_id = secret_id;
    let p_query_auto_check_in = auto_check_in;
    let p_query_auto_checkout = auto_checkout;
    let p_query_auto_comment = auto_comment;
    let p_query_force_check_in = force_check_in;
    let p_body_args = args;

    let uri_str = format!("{}/v1/secrets/{secretId}/update-ssh-restricted-commands", configuration.base_path, secretId=p_path_secret_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_auto_check_in {
        req_builder = req_builder.query(&[("autoCheckIn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_checkout {
        req_builder = req_builder.query(&[("autoCheckout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_comment {
        req_builder = req_builder.query(&[("autoComment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_force_check_in {
        req_builder = req_builder.query(&[("forceCheckIn", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsServiceUpdateSshRestrictedCommandsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

