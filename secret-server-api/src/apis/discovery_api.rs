/*
 * Secret Server Rest API
 *
 * REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.
 *
 * The version of the OpenAPI document: 11.7.61
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`discovery_service_add_discovery_source_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceAddDiscoverySourceScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_account_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateAccountRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_active_directory_discovery_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateActiveDirectoryDiscoverySourceError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_command_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateCommandSetError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_dependency_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateDependencyRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_dependency_template_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateDependencyTemplateAsyncError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_discovery_source_scanner_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateDiscoverySourceScannerSettingsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_discovery_source_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateDiscoverySourceV2Error {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_scan_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateScanTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_create_secret_search_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceCreateSecretSearchFilterError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_delete_account_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDeleteAccountRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_delete_computers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDeleteComputersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_delete_dependency_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDeleteDependencyRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_discovery_account_import`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDiscoveryAccountImportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_discovery_dependency_import`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDiscoveryDependencyImportError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_duplicate_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceDuplicateScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_account_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetAccountRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_account_rule_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetAccountRuleInfoError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_account_rule_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetAccountRuleStateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_available_discovery_source_scanners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetAvailableDiscoverySourceScannersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_command_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetCommandSetError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_command_set_test_parameters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetCommandSetTestParametersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_computer_scan_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetComputerScanLogsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_dependency_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDependencyRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_dependency_rule_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDependencyRuleInfoError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoveryConfigurationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoverySourceError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_source_audits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoverySourceAuditsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_source_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoverySourceFilterError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_source_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoverySourceScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_source_stub`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoverySourceStubError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_discovery_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetDiscoveryStatusError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_computer_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkComputerAccountError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_computer_item`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkComputerItemError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_directory_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkDirectoryAccountError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_directory_account_services`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkDirectoryAccountServicesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkPublicKeyError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_network_service_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetNetworkServiceAccountError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_rule_discovery_rule_scan_item_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetRuleDiscoveryRuleScanItemFieldsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_rule_secret_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetRuleSecretTemplatesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_rules_for_folder`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetRulesForFolderError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scan_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScanTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scan_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScanTypesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scanner_dependency_template_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScannerDependencyTemplateAsyncError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scanner_dependency_templates_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScannerDependencyTemplatesAsyncError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_scanner_dependency_types_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetScannerDependencyTypesAsyncError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_get_secret_search_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceGetSecretSearchFilterError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_command_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchCommandSetError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_dependency_template_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchDependencyTemplateAsyncError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_discovery_source_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchDiscoverySourceFilterError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_scan_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchScanTemplateError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_patch_secret_search_filter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServicePatchSecretSearchFilterError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_remove_discovery_source_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceRemoveDiscoverySourceScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_run_discovery_now`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceRunDiscoveryNowError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_save_discovery_scanner_credentials`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSaveDiscoveryScannerCredentialsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_save_discovery_scanner_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSaveDiscoveryScannerSettingsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_scan_computer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceScanComputerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_base_scanners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchBaseScannersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_command_sets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchCommandSetsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_discovery_source_scanner_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchDiscoverySourceScannerSettingsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_discovery_sources`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchDiscoverySourcesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_for_domain_ou`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchForDomainOuError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_network_items`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchNetworkItemsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_network_tree`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchNetworkTreeError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_rules_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchRulesAccountsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_rules_dependencies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchRulesDependenciesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_scan_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchScanTemplatesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_scanners`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchScannersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_search_secret_search_filters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSearchSecretSearchFiltersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_sort_rule_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSortRuleAccountsError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_sort_rule_dependencies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSortRuleDependenciesError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_sort_scanner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceSortScannerError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_test_command_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceTestCommandSetError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_update_account_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceUpdateAccountRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_update_dependency_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceUpdateDependencyRuleError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_update_discovery_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceUpdateDiscoveryConfigurationError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_update_discovery_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceUpdateDiscoverySourceError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discovery_service_update_discovery_source_filters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscoveryServiceUpdateDiscoverySourceFiltersError {
    Status403(models::AuthenticationFailedResponse),
    Status400(models::BadRequestResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Add the specified scanner to this discovery source.  After adding the scanner the scanner it will initially be invalid until the scanner map and scanner credentials have been updated.
pub async fn discovery_service_add_discovery_source_scanner(configuration: &configuration::Configuration, discovery_source_id: i32, args: Option<models::DiscoveryScannerDetailCreateArgs>) -> Result<models::DiscoveryScannerDetailModel, Error<DiscoveryServiceAddDiscoverySourceScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceAddDiscoverySourceScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the created discovery account rule
pub async fn discovery_service_create_account_rule(configuration: &configuration::Configuration, args: Option<models::DiscoveryRuleAccountCreateArgs>) -> Result<models::DiscoveryRuleAccountDetail, Error<DiscoveryServiceCreateAccountRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateAccountRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new active directory discovery source
pub async fn discovery_service_create_active_directory_discovery_source(configuration: &configuration::Configuration, args: Option<models::DiscoverySourceCreateArgs>) -> Result<models::DiscoverySourceModel, Error<DiscoveryServiceCreateActiveDirectoryDiscoverySourceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/active-directory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySourceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySourceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateActiveDirectoryDiscoverySourceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new SSH command set.
pub async fn discovery_service_create_command_set(configuration: &configuration::Configuration, args: Option<models::DiscoveryCommandSetCreateArgs>) -> Result<models::DiscoveryCommandSetModel, Error<DiscoveryServiceCreateCommandSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/command-sets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryCommandSetModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryCommandSetModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateCommandSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the created discovery dependency rule
pub async fn discovery_service_create_dependency_rule(configuration: &configuration::Configuration, args: Option<models::DiscoveryRuleDependencyCreateArgs>) -> Result<models::DiscoveryRuleDependencyDetail, Error<DiscoveryServiceCreateDependencyRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/dependencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateDependencyRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new Dependency Template
pub async fn discovery_service_create_dependency_template_async(configuration: &configuration::Configuration, args: Option<models::DiscoveryScannerDependencyTemplateCreateArgs>) -> Result<models::DiscoveryScannerDependencyTemplateModel, Error<DiscoveryServiceCreateDependencyTemplateAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scanners/dependency-template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateDependencyTemplateAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a scanner setting on a discovery source
pub async fn discovery_service_create_discovery_source_scanner_settings(configuration: &configuration::Configuration, discovery_source_id: i32, args: Option<models::DiscoveryScannerSettingCreateArgs>) -> Result<models::DiscoveryScannerSettingViewModel, Error<DiscoveryServiceCreateDiscoverySourceScannerSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanner-settings", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerSettingViewModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerSettingViewModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateDiscoverySourceScannerSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create an empty discovery source that does not have any scanners.
pub async fn discovery_service_create_discovery_source_v2(configuration: &configuration::Configuration, args: Option<models::DiscoverySourceCreateArgsV2>) -> Result<models::DiscoverySourceModel, Error<DiscoveryServiceCreateDiscoverySourceV2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v2/discovery/source", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySourceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySourceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateDiscoverySourceV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new scan template
pub async fn discovery_service_create_scan_template(configuration: &configuration::Configuration, args: Option<models::DiscoveryScanTemplateCreateArgs>) -> Result<models::DiscoveryScanTemplateModel, Error<DiscoveryServiceCreateScanTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scan-templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateScanTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new scanner
pub async fn discovery_service_create_scanner(configuration: &configuration::Configuration, args: Option<models::DiscoveryScannerCreateArgs>) -> Result<models::DiscoveryScannerModel, Error<DiscoveryServiceCreateScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scanners", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new Secret Search Filter.
pub async fn discovery_service_create_secret_search_filter(configuration: &configuration::Configuration, args: Option<models::DiscoverySecretSearchFilterCreateArgs>) -> Result<models::DiscoverySecretSearchFilterModel, Error<DiscoveryServiceCreateSecretSearchFilterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/secret-search-filters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceCreateSecretSearchFilterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the model indicating result of the account rule delete
pub async fn discovery_service_delete_account_rule(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryRuleAccountDeleteResult, Error<DiscoveryServiceDeleteAccountRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/rules/accounts/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountDeleteResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountDeleteResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDeleteAccountRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the specified computers
pub async fn discovery_service_delete_computers(configuration: &configuration::Configuration, args: Option<models::DiscoveryComputerDeleteArgs>) -> Result<models::DiscoveryComputerDeleteResultsModel, Error<DiscoveryServiceDeleteComputersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/network/item/computer/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryComputerDeleteResultsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryComputerDeleteResultsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDeleteComputersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the model indicating result of the dependency rule delete
pub async fn discovery_service_delete_dependency_rule(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryRuleDependencyDeleteResult, Error<DiscoveryServiceDeleteDependencyRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencyDeleteResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencyDeleteResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDeleteDependencyRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Starts a discovery account import bulk operation
pub async fn discovery_service_discovery_account_import(configuration: &configuration::Configuration, args: Option<models::DiscoveryImportArgs>) -> Result<models::BulkOperationResponseMessage, Error<DiscoveryServiceDiscoveryAccountImportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/account/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDiscoveryAccountImportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Starts a discovery dependency import bulk operation
pub async fn discovery_service_discovery_dependency_import(configuration: &configuration::Configuration, args: Option<models::DiscoveryDependencyImportArgs>) -> Result<models::BulkOperationResponseMessage, Error<DiscoveryServiceDiscoveryDependencyImportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkOperationResponseMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkOperationResponseMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDiscoveryDependencyImportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Duplicate a new scanner
pub async fn discovery_service_duplicate_scanner(configuration: &configuration::Configuration, args: Option<models::DiscoveryScannerDuplicateArgs>) -> Result<models::DiscoveryScannerModel, Error<DiscoveryServiceDuplicateScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scanners/duplicate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceDuplicateScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery account rule
pub async fn discovery_service_get_account_rule(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryRuleAccountDetail, Error<DiscoveryServiceGetAccountRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/rules/accounts/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetAccountRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery account rule info
pub async fn discovery_service_get_account_rule_info(configuration: &configuration::Configuration, secret_template_id: i32) -> Result<models::DiscoveryRuleAccountInfo, Error<DiscoveryServiceGetAccountRuleInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_template_id = secret_template_id;

    let uri_str = format!("{}/v1/discovery/rules/accounts/info/{secretTemplateId}", configuration.base_path, secretTemplateId=p_path_secret_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetAccountRuleInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery account rule state
pub async fn discovery_service_get_account_rule_state(configuration: &configuration::Configuration, ) -> Result<models::DiscoveryRuleAccountState, Error<DiscoveryServiceGetAccountRuleStateError>> {

    let uri_str = format!("{}/v1/discovery/rules/accounts/state", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountState`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountState`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetAccountRuleStateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the scanners that can be created for this specific discovery source
pub async fn discovery_service_get_available_discovery_source_scanners(configuration: &configuration::Configuration, discovery_source_id: i32) -> Result<Vec<models::DiscoveryScannerSettingTypeSummary>, Error<DiscoveryServiceGetAvailableDiscoverySourceScannersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/available-scanners", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DiscoveryScannerSettingTypeSummary&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DiscoveryScannerSettingTypeSummary&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetAvailableDiscoverySourceScannersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details for a single command set
pub async fn discovery_service_get_command_set(configuration: &configuration::Configuration, command_set_id: i32) -> Result<models::DiscoveryCommandSetModel, Error<DiscoveryServiceGetCommandSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_command_set_id = command_set_id;

    let uri_str = format!("{}/v1/discovery/command-sets/{commandSetId}", configuration.base_path, commandSetId=p_path_command_set_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryCommandSetModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryCommandSetModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetCommandSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the test parameters for a single command set
pub async fn discovery_service_get_command_set_test_parameters(configuration: &configuration::Configuration, command_set_id: i32) -> Result<models::DiscoveryCommandSetTestParametersModel, Error<DiscoveryServiceGetCommandSetTestParametersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_command_set_id = command_set_id;

    let uri_str = format!("{}/v1/discovery/command-sets/{commandSetId}/test-parameters", configuration.base_path, commandSetId=p_path_command_set_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryCommandSetTestParametersModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryCommandSetTestParametersModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetCommandSetTestParametersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the computer scan logs based on the filter criteria.
pub async fn discovery_service_get_computer_scan_logs(configuration: &configuration::Configuration, filter_computer_id: Option<i32>, filter_discovery_item_scanner_id: Option<i32>, filter_discovery_source_id: Option<i32>, filter_log_level: Option<bool>, filter_scan_end_date: Option<String>, filter_scan_item_template_id: Option<i32>, filter_scan_start_date: Option<String>, filter_search_text: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfNetworkComputerLogModel, Error<DiscoveryServiceGetComputerScanLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_computer_id = filter_computer_id;
    let p_query_filter_discovery_item_scanner_id = filter_discovery_item_scanner_id;
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_log_level = filter_log_level;
    let p_query_filter_scan_end_date = filter_scan_end_date;
    let p_query_filter_scan_item_template_id = filter_scan_item_template_id;
    let p_query_filter_scan_start_date = filter_scan_start_date;
    let p_query_filter_search_text = filter_search_text;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/network/item/computer/scan/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_computer_id {
        req_builder = req_builder.query(&[("filter.computerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_item_scanner_id {
        req_builder = req_builder.query(&[("filter.discoveryItemScannerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_log_level {
        req_builder = req_builder.query(&[("filter.logLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_end_date {
        req_builder = req_builder.query(&[("filter.scanEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_item_template_id {
        req_builder = req_builder.query(&[("filter.scanItemTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_start_date {
        req_builder = req_builder.query(&[("filter.scanStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfNetworkComputerLogModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfNetworkComputerLogModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetComputerScanLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery dependency rule
pub async fn discovery_service_get_dependency_rule(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryRuleDependencyDetail, Error<DiscoveryServiceGetDependencyRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDependencyRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery dependency rule info
pub async fn discovery_service_get_dependency_rule_info(configuration: &configuration::Configuration, scan_template_id: i32) -> Result<models::DiscoveryRuleDependencyInfo, Error<DiscoveryServiceGetDependencyRuleInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_scan_template_id = scan_template_id;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/info/{scanTemplateId}", configuration.base_path, scanTemplateId=p_path_scan_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDependencyRuleInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Discovery Configuration
pub async fn discovery_service_get_discovery_configuration(configuration: &configuration::Configuration, ) -> Result<models::DiscoveryConfigurationModel, Error<DiscoveryServiceGetDiscoveryConfigurationError>> {

    let uri_str = format!("{}/v1/discovery/configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryConfigurationModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryConfigurationModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoveryConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the discovery source
pub async fn discovery_service_get_discovery_source(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoverySourceModel, Error<DiscoveryServiceGetDiscoverySourceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/source/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySourceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySourceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoverySourceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Discovery Source Audits
pub async fn discovery_service_get_discovery_source_audits(configuration: &configuration::Configuration, is_exporting: Option<bool>, filter_discovery_source_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoverySourceAuditModel, Error<DiscoveryServiceGetDiscoverySourceAuditsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_is_exporting = is_exporting;
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery-source/audit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_is_exporting {
        req_builder = req_builder.query(&[("isExporting", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoverySourceAuditModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoverySourceAuditModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoverySourceAuditsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the source filter for a discovery source
pub async fn discovery_service_get_discovery_source_filter(configuration: &configuration::Configuration, id: i32) -> Result<models::DomainDiscoveryScopeModel, Error<DiscoveryServiceGetDiscoverySourceFilterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/source/{id}/filter", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainDiscoveryScopeModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainDiscoveryScopeModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoverySourceFilterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details for a specific discovery scanner
pub async fn discovery_service_get_discovery_source_scanner(configuration: &configuration::Configuration, discovery_item_scanner_id: i32, discovery_source_id: i32) -> Result<models::DiscoveryScannerDetailModel, Error<DiscoveryServiceGetDiscoverySourceScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_item_scanner_id = discovery_item_scanner_id;
    let p_path_discovery_source_id = discovery_source_id;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners/{discoveryItemScannerId}", configuration.base_path, discoveryItemScannerId=p_path_discovery_item_scanner_id, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerDetailModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerDetailModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoverySourceScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a Discovery Source Stub
pub async fn discovery_service_get_discovery_source_stub(configuration: &configuration::Configuration, type_id: i32) -> Result<models::DiscoverySourceModel, Error<DiscoveryServiceGetDiscoverySourceStubError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_type_id = type_id;

    let uri_str = format!("{}/v1/discovery/source/stub/{typeId}", configuration.base_path, typeId=p_path_type_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySourceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySourceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoverySourceStubError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Discovery Status
pub async fn discovery_service_get_discovery_status(configuration: &configuration::Configuration, include_extended_metrics: Option<bool>) -> Result<models::DiscoveryStatusModel, Error<DiscoveryServiceGetDiscoveryStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_include_extended_metrics = include_extended_metrics;

    let uri_str = format!("{}/v1/discovery/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_extended_metrics {
        req_builder = req_builder.query(&[("includeExtendedMetrics", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryStatusModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryStatusModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetDiscoveryStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a computer account that has been discovered and is linked in a discovery source and network tree
pub async fn discovery_service_get_network_computer_account(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryNetworkComputerAccountItemDetail, Error<DiscoveryServiceGetNetworkComputerAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/network/item/computer-account/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryNetworkComputerAccountItemDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryNetworkComputerAccountItemDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkComputerAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns details for a computer that has been discovered and are linked in a discovery source and network tree
pub async fn discovery_service_get_network_computer_item(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryNetworkComputerItemDetail, Error<DiscoveryServiceGetNetworkComputerItemError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/network/item/computer/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryNetworkComputerItemDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryNetworkComputerItemDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkComputerItemError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a directory account that has been discovered and is linked in a discovery source and network tree
pub async fn discovery_service_get_network_directory_account(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryNetworkDirectoryAccountItemDetail, Error<DiscoveryServiceGetNetworkDirectoryAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/network/item/directory-account/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryNetworkDirectoryAccountItemDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryNetworkDirectoryAccountItemDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkDirectoryAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns service accounts linked to a directory account that has been discovered and is linked in a discovery source and network tree
pub async fn discovery_service_get_network_directory_account_services(configuration: &configuration::Configuration, id: i32, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryNetworkServiceAccount, Error<DiscoveryServiceGetNetworkDirectoryAccountServicesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/network/item/directory-account/{id}/services", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryNetworkServiceAccount`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryNetworkServiceAccount`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkDirectoryAccountServicesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a public key that has been discovered and is linked in a discovery source and network tree
pub async fn discovery_service_get_network_public_key(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryNetworkPublicKeyItemDetail, Error<DiscoveryServiceGetNetworkPublicKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/network/item/public-key/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryNetworkPublicKeyItemDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryNetworkPublicKeyItemDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkPublicKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a service account that has been discovered and is linked in a discovery source and network tree
pub async fn discovery_service_get_network_service_account(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryNetworkServiceAccountItemDetail, Error<DiscoveryServiceGetNetworkServiceAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/network/item/service-account/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryNetworkServiceAccountItemDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryNetworkServiceAccountItemDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetNetworkServiceAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery rule scan item fields
pub async fn discovery_service_get_rule_discovery_rule_scan_item_fields(configuration: &configuration::Configuration, scan_template_id: i32) -> Result<Vec<models::DiscoveryRuleScanItemField>, Error<DiscoveryServiceGetRuleDiscoveryRuleScanItemFieldsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_scan_template_id = scan_template_id;

    let uri_str = format!("{}/v1/discovery/rules/scan-item-fields/{scanTemplateId}", configuration.base_path, scanTemplateId=p_path_scan_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DiscoveryRuleScanItemField&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DiscoveryRuleScanItemField&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetRuleDiscoveryRuleScanItemFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery rule secret templates
pub async fn discovery_service_get_rule_secret_templates(configuration: &configuration::Configuration, scan_template_id: i32) -> Result<Vec<models::DiscoveryRuleSecretTemplate>, Error<DiscoveryServiceGetRuleSecretTemplatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_scan_template_id = scan_template_id;

    let uri_str = format!("{}/v1/discovery/rules/secret-templates/{scanTemplateId}", configuration.base_path, scanTemplateId=p_path_scan_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DiscoveryRuleSecretTemplate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DiscoveryRuleSecretTemplate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetRuleSecretTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery rules for a folder
pub async fn discovery_service_get_rules_for_folder(configuration: &configuration::Configuration, folder_id: i32) -> Result<Vec<models::FolderDiscoveryImportRuleModel>, Error<DiscoveryServiceGetRulesForFolderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_folder_id = folder_id;

    let uri_str = format!("{}/v1/discovery/rules/folder/{folderId}", configuration.base_path, folderId=p_path_folder_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FolderDiscoveryImportRuleModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FolderDiscoveryImportRuleModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetRulesForFolderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details for a scan template
pub async fn discovery_service_get_scan_template(configuration: &configuration::Configuration, scan_template_id: i32) -> Result<models::DiscoveryScanTemplateModel, Error<DiscoveryServiceGetScanTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_scan_template_id = scan_template_id;

    let uri_str = format!("{}/v1/discovery/scan-templates/{scanTemplateId}", configuration.base_path, scanTemplateId=p_path_scan_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScanTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the scan types
pub async fn discovery_service_get_scan_types(configuration: &configuration::Configuration, ) -> Result<Vec<models::DiscoveryScanTypeSummary>, Error<DiscoveryServiceGetScanTypesError>> {

    let uri_str = format!("{}/v1/discovery/scan-types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DiscoveryScanTypeSummary&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DiscoveryScanTypeSummary&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScanTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details for a single scanner
pub async fn discovery_service_get_scanner(configuration: &configuration::Configuration, item_scanner_id: i32) -> Result<models::DiscoveryScannerModel, Error<DiscoveryServiceGetScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_item_scanner_id = item_scanner_id;

    let uri_str = format!("{}/v1/discovery/scanners/{itemScannerId}", configuration.base_path, itemScannerId=p_path_item_scanner_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Scanner Dependency Template
pub async fn discovery_service_get_scanner_dependency_template_async(configuration: &configuration::Configuration, id: i32) -> Result<models::DiscoveryScannerDependencyTemplateModel, Error<DiscoveryServiceGetScannerDependencyTemplateAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/v1/discovery/scanners/dependency-template/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScannerDependencyTemplateAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Scanner Dependency Templates
pub async fn discovery_service_get_scanner_dependency_templates_async(configuration: &configuration::Configuration, filter_secret_dependency_type_id: Option<i32>, filter_status: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryScannerDependencyTemplateSummaryModel, Error<DiscoveryServiceGetScannerDependencyTemplatesAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_secret_dependency_type_id = filter_secret_dependency_type_id;
    let p_query_filter_status = filter_status;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/scanners/dependency-templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_secret_dependency_type_id {
        req_builder = req_builder.query(&[("filter.secretDependencyTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status {
        req_builder = req_builder.query(&[("filter.status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryScannerDependencyTemplateSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryScannerDependencyTemplateSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScannerDependencyTemplatesAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Scanner Dependency Types
pub async fn discovery_service_get_scanner_dependency_types_async(configuration: &configuration::Configuration, filter_valid_for_dependency_changer: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryScannerDependencyTypeSummaryModelAndDiscoveryScannerDependencyTypeFilter, Error<DiscoveryServiceGetScannerDependencyTypesAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_valid_for_dependency_changer = filter_valid_for_dependency_changer;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/scanners/dependency-types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_valid_for_dependency_changer {
        req_builder = req_builder.query(&[("filter.validForDependencyChanger", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryScannerDependencyTypeSummaryModelAndDiscoveryScannerDependencyTypeFilter`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryScannerDependencyTypeSummaryModelAndDiscoveryScannerDependencyTypeFilter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetScannerDependencyTypesAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details for a single Secret Search Filter
pub async fn discovery_service_get_secret_search_filter(configuration: &configuration::Configuration, secret_search_filter_id: i32) -> Result<models::DiscoverySecretSearchFilterModel, Error<DiscoveryServiceGetSecretSearchFilterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_search_filter_id = secret_search_filter_id;

    let uri_str = format!("{}/v1/discovery/secret-search-filters/{secretSearchFilterId}", configuration.base_path, secretSearchFilterId=p_path_secret_search_filter_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceGetSecretSearchFilterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update values on a command set
pub async fn discovery_service_patch_command_set(configuration: &configuration::Configuration, command_set_id: i32, args: Option<models::DiscoveryCommandSetUpdateArgs>) -> Result<models::DiscoveryCommandSetModel, Error<DiscoveryServicePatchCommandSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_command_set_id = command_set_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/command-sets/{commandSetId}", configuration.base_path, commandSetId=p_path_command_set_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryCommandSetModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryCommandSetModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchCommandSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update values on a Dependency Template
pub async fn discovery_service_patch_dependency_template_async(configuration: &configuration::Configuration, id: i32, args: Option<models::DiscoveryScannerDependencyTemplateUpdateArgs>) -> Result<models::DiscoveryScannerDependencyTemplateModel, Error<DiscoveryServicePatchDependencyTemplateAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scanners/dependency-template/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerDependencyTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchDependencyTemplateAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patches the properties on a single discovery source filter
pub async fn discovery_service_patch_discovery_source_filter(configuration: &configuration::Configuration, discovery_source_id: i32, member_id: i32, args: Option<models::DiscoverySourceFilterPatchArgs>) -> Result<models::DomainDiscoveryScopeFilterModel, Error<DiscoveryServicePatchDiscoverySourceFilterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_path_member_id = member_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/filter/{memberId}", configuration.base_path, discoverySourceId=p_path_discovery_source_id, memberId=p_path_member_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainDiscoveryScopeFilterModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainDiscoveryScopeFilterModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchDiscoverySourceFilterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update values on a scan template
pub async fn discovery_service_patch_scan_template(configuration: &configuration::Configuration, scan_template_id: i32, args: Option<models::DiscoveryScanTemplateUpdateArgs>) -> Result<models::DiscoveryScanTemplateModel, Error<DiscoveryServicePatchScanTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_scan_template_id = scan_template_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scan-templates/{scanTemplateId}", configuration.base_path, scanTemplateId=p_path_scan_template_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScanTemplateModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchScanTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update values on a scanner
pub async fn discovery_service_patch_scanner(configuration: &configuration::Configuration, item_scanner_id: i32, args: Option<models::DiscoveryScannerUpdateArgs>) -> Result<models::DiscoveryScannerModel, Error<DiscoveryServicePatchScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_item_scanner_id = item_scanner_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/scanners/{itemScannerId}", configuration.base_path, itemScannerId=p_path_item_scanner_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update values on a Secret Search Filter
pub async fn discovery_service_patch_secret_search_filter(configuration: &configuration::Configuration, secret_search_filter_id: i32, args: Option<models::DiscoverySecretSearchFilterUpdateArgs>) -> Result<models::DiscoverySecretSearchFilterModel, Error<DiscoveryServicePatchSecretSearchFilterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_secret_search_filter_id = secret_search_filter_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/secret-search-filters/{secretSearchFilterId}", configuration.base_path, secretSearchFilterId=p_path_secret_search_filter_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySecretSearchFilterModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServicePatchSecretSearchFilterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove the specified scanner from the discovery source
pub async fn discovery_service_remove_discovery_source_scanner(configuration: &configuration::Configuration, discovery_item_scanner_id: i32, discovery_source_id: i32) -> Result<models::RemoveDiscoveryScannerResultModel, Error<DiscoveryServiceRemoveDiscoverySourceScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_item_scanner_id = discovery_item_scanner_id;
    let p_path_discovery_source_id = discovery_source_id;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners/{discoveryItemScannerId}", configuration.base_path, discoveryItemScannerId=p_path_discovery_item_scanner_id, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RemoveDiscoveryScannerResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RemoveDiscoveryScannerResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceRemoveDiscoverySourceScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Run a discovery command
pub async fn discovery_service_run_discovery_now(configuration: &configuration::Configuration, args: Option<models::DiscoveryRunArgs>) -> Result<bool, Error<DiscoveryServiceRunDiscoveryNowError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/run", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceRunDiscoveryNowError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Completely replace all the scanner credentials with this list
pub async fn discovery_service_save_discovery_scanner_credentials(configuration: &configuration::Configuration, discovery_item_scanner_id: i32, discovery_source_id: i32, args: Option<models::DiscoveryScannerCredentialsArgs>) -> Result<models::DiscoveryUpdateCredentialsResultModel, Error<DiscoveryServiceSaveDiscoveryScannerCredentialsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_item_scanner_id = discovery_item_scanner_id;
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners/{discoveryItemScannerId}/credentials", configuration.base_path, discoveryItemScannerId=p_path_discovery_item_scanner_id, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryUpdateCredentialsResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryUpdateCredentialsResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSaveDiscoveryScannerCredentialsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Completely replace all the scanner settings for this scanner
pub async fn discovery_service_save_discovery_scanner_settings(configuration: &configuration::Configuration, discovery_item_scanner_id: i32, discovery_source_id: i32, args: Option<models::DiscoveryScannerSettingsArgs>) -> Result<models::DiscoveryUpdateSettingsResultModel, Error<DiscoveryServiceSaveDiscoveryScannerSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_item_scanner_id = discovery_item_scanner_id;
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners/{discoveryItemScannerId}/settings", configuration.base_path, discoveryItemScannerId=p_path_discovery_item_scanner_id, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryUpdateSettingsResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryUpdateSettingsResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSaveDiscoveryScannerSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Run a scan on the specified computer
pub async fn discovery_service_scan_computer(configuration: &configuration::Configuration, args: Option<models::DiscoveryComputerScanArgs>) -> Result<models::DiscoveryComputerScanResultsModel, Error<DiscoveryServiceScanComputerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/network/item/computer/scan", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryComputerScanResultsModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryComputerScanResultsModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceScanComputerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search all discovery base scanners
pub async fn discovery_service_search_base_scanners(configuration: &configuration::Configuration, filter_is_active: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryBaseScannerSummary, Error<DiscoveryServiceSearchBaseScannersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_is_active = filter_is_active;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/base-scanners", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_is_active {
        req_builder = req_builder.query(&[("filter.isActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryBaseScannerSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryBaseScannerSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchBaseScannersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search all discovery command sets
pub async fn discovery_service_search_command_sets(configuration: &configuration::Configuration, filter_scan_type_id: Option<i32>, filter_search_text: Option<&str>, filter_status: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryCommandSetSummary, Error<DiscoveryServiceSearchCommandSetsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_scan_type_id = filter_scan_type_id;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_status = filter_status;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/command-sets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_scan_type_id {
        req_builder = req_builder.query(&[("filter.scanTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status {
        req_builder = req_builder.query(&[("filter.status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryCommandSetSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryCommandSetSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchCommandSetsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the scanner settings for a specific discovery source
pub async fn discovery_service_search_discovery_source_scanner_settings(configuration: &configuration::Configuration, discovery_source_id: i32) -> Result<Vec<models::DiscoveryScannerSettingSummaryModel>, Error<DiscoveryServiceSearchDiscoverySourceScannerSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanner-settings/search", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DiscoveryScannerSettingSummaryModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DiscoveryScannerSettingSummaryModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchDiscoverySourceScannerSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery sources
pub async fn discovery_service_search_discovery_sources(configuration: &configuration::Configuration, filter_discovery_source_name: Option<&str>, filter_discovery_source_type: Option<&str>, filter_include_active: Option<bool>, filter_include_inactive: Option<bool>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoverySourceSummaryModel, Error<DiscoveryServiceSearchDiscoverySourcesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_source_name = filter_discovery_source_name;
    let p_query_filter_discovery_source_type = filter_discovery_source_type;
    let p_query_filter_include_active = filter_include_active;
    let p_query_filter_include_inactive = filter_include_inactive;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/sources", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_source_name {
        req_builder = req_builder.query(&[("filter.discoverySourceName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_source_type {
        req_builder = req_builder.query(&[("filter.discoverySourceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_active {
        req_builder = req_builder.query(&[("filter.includeActive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_inactive {
        req_builder = req_builder.query(&[("filter.includeInactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoverySourceSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoverySourceSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchDiscoverySourcesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the discovery source OU
pub async fn discovery_service_search_for_domain_ou(configuration: &configuration::Configuration, discovery_source_id: i32, include: Option<bool>, search_text: Option<&str>, selected_ids: Option<Vec<String>>, take: Option<i32>) -> Result<Vec<models::OuModel>, Error<DiscoveryServiceSearchForDomainOuError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_query_include = include;
    let p_query_search_text = search_text;
    let p_query_selected_ids = selected_ids;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/ou", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include {
        req_builder = req_builder.query(&[("include", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_text {
        req_builder = req_builder.query(&[("searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_selected_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("selectedIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("selectedIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OuModel&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OuModel&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchForDomainOuError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns items that have been discovered and are linked in a discovery source and network tree
pub async fn discovery_service_search_network_items(configuration: &configuration::Configuration, filter_created_end_date: Option<String>, filter_created_start_date: Option<String>, filter_discovery_rule_id: Option<i32>, filter_discovery_source_id: Option<i32>, filter_has_computer_accounts: Option<bool>, filter_item_type: Option<&str>, filter_last_polled_end_date: Option<String>, filter_last_polled_start_date: Option<String>, filter_last_reached_end_date: Option<String>, filter_last_reached_start_date: Option<String>, filter_managed: Option<bool>, filter_operating_system: Option<&str>, filter_organizational_unit_id: Option<i32>, filter_scan_item_template_id: Option<i32>, filter_search_children: Option<bool>, filter_search_text: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryNetworkItemSummary, Error<DiscoveryServiceSearchNetworkItemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_created_end_date = filter_created_end_date;
    let p_query_filter_created_start_date = filter_created_start_date;
    let p_query_filter_discovery_rule_id = filter_discovery_rule_id;
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_has_computer_accounts = filter_has_computer_accounts;
    let p_query_filter_item_type = filter_item_type;
    let p_query_filter_last_polled_end_date = filter_last_polled_end_date;
    let p_query_filter_last_polled_start_date = filter_last_polled_start_date;
    let p_query_filter_last_reached_end_date = filter_last_reached_end_date;
    let p_query_filter_last_reached_start_date = filter_last_reached_start_date;
    let p_query_filter_managed = filter_managed;
    let p_query_filter_operating_system = filter_operating_system;
    let p_query_filter_organizational_unit_id = filter_organizational_unit_id;
    let p_query_filter_scan_item_template_id = filter_scan_item_template_id;
    let p_query_filter_search_children = filter_search_children;
    let p_query_filter_search_text = filter_search_text;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/network/items", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_created_end_date {
        req_builder = req_builder.query(&[("filter.createdEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_created_start_date {
        req_builder = req_builder.query(&[("filter.createdStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_rule_id {
        req_builder = req_builder.query(&[("filter.discoveryRuleId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_has_computer_accounts {
        req_builder = req_builder.query(&[("filter.hasComputerAccounts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_item_type {
        req_builder = req_builder.query(&[("filter.itemType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_last_polled_end_date {
        req_builder = req_builder.query(&[("filter.lastPolledEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_last_polled_start_date {
        req_builder = req_builder.query(&[("filter.lastPolledStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_last_reached_end_date {
        req_builder = req_builder.query(&[("filter.lastReachedEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_last_reached_start_date {
        req_builder = req_builder.query(&[("filter.lastReachedStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_managed {
        req_builder = req_builder.query(&[("filter.managed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_operating_system {
        req_builder = req_builder.query(&[("filter.operatingSystem", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_organizational_unit_id {
        req_builder = req_builder.query(&[("filter.organizationalUnitId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_item_template_id {
        req_builder = req_builder.query(&[("filter.scanItemTemplateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_children {
        req_builder = req_builder.query(&[("filter.searchChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryNetworkItemSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryNetworkItemSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchNetworkItemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search network tree for discovery
pub async fn discovery_service_search_network_tree(configuration: &configuration::Configuration, filter_discovery_source_id: Option<i32>, filter_parent_id: Option<i32>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfNetworkTreeSummaryModel, Error<DiscoveryServiceSearchNetworkTreeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_parent_id = filter_parent_id;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/network/tree", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_parent_id {
        req_builder = req_builder.query(&[("filter.parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfNetworkTreeSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfNetworkTreeSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchNetworkTreeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery account rules
pub async fn discovery_service_search_rules_accounts(configuration: &configuration::Configuration, filter_discovery_source_id: Option<i32>, filter_status_filter: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryRuleAccountSummary, Error<DiscoveryServiceSearchRulesAccountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_status_filter = filter_status_filter;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/rules/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status_filter {
        req_builder = req_builder.query(&[("filter.statusFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryRuleAccountSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryRuleAccountSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchRulesAccountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery dependency rules
pub async fn discovery_service_search_rules_dependencies(configuration: &configuration::Configuration, filter_discovery_source_id: Option<i32>, filter_status_filter: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryRuleDependencySummary, Error<DiscoveryServiceSearchRulesDependenciesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_status_filter = filter_status_filter;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/rules/dependencies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status_filter {
        req_builder = req_builder.query(&[("filter.statusFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryRuleDependencySummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryRuleDependencySummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchRulesDependenciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns discovery scan templates
pub async fn discovery_service_search_scan_templates(configuration: &configuration::Configuration, filter_discovery_scan_type_id: Option<i32>, filter_discovery_source_id: Option<i32>, filter_include_input: Option<bool>, filter_only_include_base_scan_templates: Option<bool>, filter_search_text: Option<&str>, filter_status: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryScanTemplateSummaryModel, Error<DiscoveryServiceSearchScanTemplatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_scan_type_id = filter_discovery_scan_type_id;
    let p_query_filter_discovery_source_id = filter_discovery_source_id;
    let p_query_filter_include_input = filter_include_input;
    let p_query_filter_only_include_base_scan_templates = filter_only_include_base_scan_templates;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_status = filter_status;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/scan-templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_scan_type_id {
        req_builder = req_builder.query(&[("filter.discoveryScanTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_discovery_source_id {
        req_builder = req_builder.query(&[("filter.discoverySourceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_include_input {
        req_builder = req_builder.query(&[("filter.includeInput", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_only_include_base_scan_templates {
        req_builder = req_builder.query(&[("filter.onlyIncludeBaseScanTemplates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status {
        req_builder = req_builder.query(&[("filter.status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryScanTemplateSummaryModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryScanTemplateSummaryModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchScanTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search all discovery scanners
pub async fn discovery_service_search_scanners(configuration: &configuration::Configuration, filter_discovery_item_scanner_id: Option<i32>, filter_scan_type_id: Option<i32>, filter_search_text: Option<&str>, filter_status: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoveryScannerSummary, Error<DiscoveryServiceSearchScannersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_discovery_item_scanner_id = filter_discovery_item_scanner_id;
    let p_query_filter_scan_type_id = filter_scan_type_id;
    let p_query_filter_search_text = filter_search_text;
    let p_query_filter_status = filter_status;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/scanners", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_discovery_item_scanner_id {
        req_builder = req_builder.query(&[("filter.discoveryItemScannerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_scan_type_id {
        req_builder = req_builder.query(&[("filter.scanTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_search_text {
        req_builder = req_builder.query(&[("filter.searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_status {
        req_builder = req_builder.query(&[("filter.status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoveryScannerSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoveryScannerSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchScannersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search all secret search filters
pub async fn discovery_service_search_secret_search_filters(configuration: &configuration::Configuration, filter_status: Option<&str>, skip: Option<i32>, sort_by_left_square_bracket_0_right_square_bracket__direction: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__name: Option<&str>, sort_by_left_square_bracket_0_right_square_bracket__priority: Option<i32>, take: Option<i32>) -> Result<models::PagingOfDiscoverySecretSearchFilterSummary, Error<DiscoveryServiceSearchSecretSearchFiltersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_filter_status = filter_status;
    let p_query_skip = skip;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__direction = sort_by_left_square_bracket_0_right_square_bracket__direction;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__name = sort_by_left_square_bracket_0_right_square_bracket__name;
    let p_query_sort_by_left_square_bracket_0_right_square_bracket__priority = sort_by_left_square_bracket_0_right_square_bracket__priority;
    let p_query_take = take;

    let uri_str = format!("{}/v1/discovery/secret-search-filters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_status {
        req_builder = req_builder.query(&[("filter.status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__direction {
        req_builder = req_builder.query(&[("sortBy[0].direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__name {
        req_builder = req_builder.query(&[("sortBy[0].name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_by_left_square_bracket_0_right_square_bracket__priority {
        req_builder = req_builder.query(&[("sortBy[0].priority", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PagingOfDiscoverySecretSearchFilterSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PagingOfDiscoverySecretSearchFilterSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSearchSecretSearchFiltersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sorts the Rule Accounts.
pub async fn discovery_service_sort_rule_accounts(configuration: &configuration::Configuration, args: Option<models::DiscoveryRuleAccountSortArgs>) -> Result<models::DiscoveryRuleAccountSortResultModel, Error<DiscoveryServiceSortRuleAccountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/accounts/sort", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountSortResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountSortResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSortRuleAccountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sorts the Rule Dependencies.
pub async fn discovery_service_sort_rule_dependencies(configuration: &configuration::Configuration, args: Option<models::DiscoveryRuleDependencySortArgs>) -> Result<models::DiscoveryRuleDependencySortResultModel, Error<DiscoveryServiceSortRuleDependenciesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/sort", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencySortResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencySortResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSortRuleDependenciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sorts the scanners for execution.
pub async fn discovery_service_sort_scanner(configuration: &configuration::Configuration, discovery_source_id: i32, args: Option<models::DiscoveryScannerSortArgs>) -> Result<models::DiscoveryScannerSortResultModel, Error<DiscoveryServiceSortScannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/scanners/sort", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryScannerSortResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryScannerSortResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceSortScannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test the discover command set
pub async fn discovery_service_test_command_set(configuration: &configuration::Configuration, command_set_id: i32, args: Option<models::DiscoveryCommandSetTestArgs>) -> Result<models::DiscoveryCommandSetTestResultModel, Error<DiscoveryServiceTestCommandSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_command_set_id = command_set_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/command-sets/{commandSetId}/test", configuration.base_path, commandSetId=p_path_command_set_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryCommandSetTestResultModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryCommandSetTestResultModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceTestCommandSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the updated discovery account rule
pub async fn discovery_service_update_account_rule(configuration: &configuration::Configuration, id: i32, args: Option<models::DiscoveryRuleAccountUpdateArgs>) -> Result<models::DiscoveryRuleAccountDetail, Error<DiscoveryServiceUpdateAccountRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/accounts/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleAccountDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceUpdateAccountRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the updated discovery dependency rule
pub async fn discovery_service_update_dependency_rule(configuration: &configuration::Configuration, id: i32, args: Option<models::DiscoveryRuleDependencyUpdateArgs>) -> Result<models::DiscoveryRuleDependencyDetail, Error<DiscoveryServiceUpdateDependencyRuleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/rules/dependencies/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryRuleDependencyDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceUpdateDependencyRuleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update discovery configuration
pub async fn discovery_service_update_discovery_configuration(configuration: &configuration::Configuration, args: Option<models::DiscoveryConfigurationUpdateArgs>) -> Result<models::DiscoveryConfigurationModel, Error<DiscoveryServiceUpdateDiscoveryConfigurationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoveryConfigurationModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoveryConfigurationModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceUpdateDiscoveryConfigurationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing discovery source using the existing discovery source ID
pub async fn discovery_service_update_discovery_source(configuration: &configuration::Configuration, id: i32, args: Option<models::DiscoverySourceUpdateArgs>) -> Result<models::DiscoverySourceModel, Error<DiscoveryServiceUpdateDiscoverySourceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{id}", configuration.base_path, id=p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscoverySourceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscoverySourceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceUpdateDiscoverySourceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the full collection of discovery source filters for a discovery source
pub async fn discovery_service_update_discovery_source_filters(configuration: &configuration::Configuration, discovery_source_id: i32, args: Option<models::DiscoverySourceFiltersUpdateArgs>) -> Result<models::DomainDiscoveryScopeModel, Error<DiscoveryServiceUpdateDiscoverySourceFiltersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_discovery_source_id = discovery_source_id;
    let p_body_args = args;

    let uri_str = format!("{}/v1/discovery/source/{discoverySourceId}/filters", configuration.base_path, discoverySourceId=p_path_discovery_source_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_args);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainDiscoveryScopeModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainDiscoveryScopeModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscoveryServiceUpdateDiscoverySourceFiltersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

